<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Penguin Mex</title>
    <style>
        /* --- Enhanced Visual Styling --- */
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');

        :root {
            --primary-color: #34495e; /* Dark Slate Blue */
            --secondary-color: #3498db; /* Bright Blue */
            --accent-color: #e74c3c; /* Red */
            --background-start: #f8f9fa; /* Very Light Gray */
            --background-end: #e9ecef;   /* Light Gray */
            --text-color: #2c3e50; /* Darker Slate Blue */
            --light-text: #ffffff;
            --border-color: #ced4da; /* Medium Gray */
            --dice-bg: #fdfdfd; /* Almost White */
            --dice-dot: #2c3e50; /* Dark Slate Blue */
            --special-message-bg: #fff3cd; /* Light Yellow */
            --special-message-border: #ffeeba;
            --special-message-text: #856404;
            --shadow-color: rgba(0, 0, 0, 0.15);
            --shadow-color-light: rgba(0, 0, 0, 0.08);
            /* Dice Size */
            --dice-size: 160px;
            --dot-size: 30px;
            --dice-padding: 15px;
            --dice-gap: 8px;
            --dice-radius: 25px;
        }

        html {
             height: 100%;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-image: linear-gradient(to bottom, var(--background-start), var(--background-end));
            color: var(--text-color);
            margin: 0;
            padding: 15px 15px 25px 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100%;
            overflow-x: hidden;
            overflow-y: auto;
            box-sizing: border-box;
        }

        .title-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-shrink: 0;
        }

        .penguin-logo {
            height: 40px;
            width: auto;
        }

        h1 {
            color: var(--primary-color);
            text-align: center;
            margin: 0;
            font-weight: 600;
            font-size: 2.0em;
            text-shadow: 1px 1px 2px var(--shadow-color-light);
        }

        h2, h3 {
            color: var(--primary-color);
            text-align: center;
            margin-top: 0;
            margin-bottom: 15px;
            font-weight: 600;
        }

        h2 { font-size: 1.6em; }
        h3 { font-size: 1.3em; }

        .container {
            background-color: var(--light-text);
            padding: 25px;
            border-radius: 16px;
            box-shadow: 0 8px 25px var(--shadow-color);
            border: 1px solid rgba(0,0,0,0.05);
            width: 95%;
            max-width: 480px;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 18px;
            flex-shrink: 0;
        }

        #setup-fase { display: flex; flex-direction: column; align-items: center; }
        #player-input {
            padding: 12px 18px; border: 1px solid var(--border-color);
            border-radius: 8px; width: 80%; font-size: 1em;
            margin-bottom: 10px; transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        #player-input:focus {
            border-color: var(--secondary-color);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
            outline: none;
        }
        #player-list {
            list-style: none; padding: 0; margin-top: 10px;
            width: 100%; text-align: center;
        }
        #player-list li {
            background-color: var(--background-start);
            padding: 9px 14px; margin-bottom: 7px;
            border-radius: 6px; font-weight: 600; color: var(--primary-color);
            border: 1px solid var(--border-color);
            transition: transform 0.2s ease;
        }
         #player-list li:hover {
             transform: scale(1.02);
         }

        #spel-fase { display: none; flex-direction: column; align-items: center; }
        #spel-info {
            width: 100%; display: flex; justify-content: space-between;
            align-items: center; margin-bottom: 10px; padding: 0 5px;
            flex-wrap: wrap; gap: 8px;
        }
        #speler-aan-zet {
             font-size: 1.3em; font-weight: 700; margin: 0;
             color: var(--secondary-color);
             text-shadow: 1px 1px 1px var(--shadow-color-light);
        }
        #worp-info { font-size: 1.0em; font-weight: 600; margin: 0; color: var(--primary-color); }

        /* --- Bigger Dice Styling --- */
        .dice-container {
            display: flex; /* Default state */
            justify-content: center;
            gap: 50px; /* Increased gap */
            margin-bottom: 35px; /* Increased margin */
            perspective: 1500px; /* Enhanced perspective */
            min-height: calc(var(--dice-size) + 20px); /* Ensure space during animation */
            width: 100%; /* Take full width */
            box-sizing: border-box;
        }

        .die {
            width: var(--dice-size); height: var(--dice-size);
            background: linear-gradient(145deg, #ffffff, #e8e8e8);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--dice-radius);
            padding: var(--dice-padding);
            display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr);
            gap: var(--dice-gap);
            box-shadow: 10px 10px 25px rgba(0,0,0,0.15), /* Increased shadow */
                       -10px -10px 25px rgba(255,255,255,0.8),
                       inset 0 4px 7px rgba(255, 255, 255, 0.7),
                       inset 0 -4px 7px rgba(0, 0, 0, 0.06);
            cursor: default; /* Base cursor */
            transition: border-color 0.3s ease, box-shadow 0.3s ease, transform 0.5s ease-out;
            transform-style: preserve-3d;
        }
        .die.clickable {
             cursor: pointer; /* Change cursor only when truly clickable */
        }
        .die.clickable:hover {
            transform: scale(1.05) rotateY(6deg);
            box-shadow: 12px 12px 30px rgba(0,0,0,0.20), /* Enhanced hover shadow */
                       -10px -10px 25px rgba(255,255,255,0.8),
                       inset 0 4px 7px rgba(255, 255, 255, 0.7),
                       inset 0 -4px 7px rgba(0, 0, 0, 0.06);
        }
        .die.held {
            border-color: var(--accent-color);
             /* Enhanced glow */
            box-shadow: 0 0 25px var(--accent-color),
                       10px 10px 25px rgba(0,0,0,0.15),
                       -10px -10px 25px rgba(255,255,255,0.8),
                       inset 0 4px 7px rgba(255, 255, 255, 0.7),
                       inset 0 -4px 7px rgba(0, 0, 0, 0.06);
            transform: scale(1.02);
        }

        .dot {
            width: var(--dot-size); height: var(--dot-size);
            background-color: var(--dice-dot);
            border-radius: 50%;
            align-self: center; justify-self: center;
            box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.7),
                       0 0 3px rgba(0, 0, 0, 0.3);
            visibility: hidden;
        }
        /* Dot positioning remains the same */
        .dot:nth-child(1) { grid-area: 1 / 1; } .dot:nth-child(2) { grid-area: 1 / 2; } .dot:nth-child(3) { grid-area: 1 / 3; }
        .dot:nth-child(4) { grid-area: 2 / 1; } .dot:nth-child(5) { grid-area: 2 / 2; } .dot:nth-child(6) { grid-area: 2 / 3; }
        .dot:nth-child(7) { grid-area: 3 / 1; } .dot:nth-child(8) { grid-area: 3 / 2; } .dot:nth-child(9) { grid-area: 3 / 3; }
        /* Dot visibility rules remain the same */
        .die[data-value="0"] .dot { visibility: hidden; }
        .die[data-value="1"] .dot:nth-child(5) { visibility: visible; }
        .die[data-value="2"] .dot:nth-child(1), .die[data-value="2"] .dot:nth-child(9) { visibility: visible; }
        .die[data-value="3"] .dot:nth-child(1), .die[data-value="3"] .dot:nth-child(5), .die[data-value="3"] .dot:nth-child(9) { visibility: visible; }
        .die[data-value="4"] .dot:nth-child(1), .die[data-value="4"] .dot:nth-child(3), .die[data-value="4"] .dot:nth-child(7), .die[data-value="4"] .dot:nth-child(9) { visibility: visible; }
        .die[data-value="5"] .dot:nth-child(1), .die[data-value="5"] .dot:nth-child(3), .die[data-value="5"] .dot:nth-child(5), .die[data-value="5"] .dot:nth-child(7), .die[data-value="5"] .dot:nth-child(9) { visibility: visible; }
        .die[data-value="6"] .dot:nth-child(1), .die[data-value="6"] .dot:nth-child(3), .die[data-value="6"] .dot:nth-child(4), .die[data-value="6"] .dot:nth-child(6), .die[data-value="6"] .dot:nth-child(7), .die[data-value="6"] .dot:nth-child(9) { visibility: visible; }

        .score-display {
            font-size: 1.8em; font-weight: 700; color: var(--secondary-color);
            text-align: center; margin-top: 0px; margin-bottom: 15px;
            text-shadow: 1px 1px 1px var(--shadow-color-light);
        }

        .message-area {
            min-height: 25px; padding: 10px 15px;
            background-color: var(--special-message-bg);
            border: 1px solid var(--special-message-border);
            border-radius: 8px; text-align: center;
            font-weight: 600; color: var(--special-message-text);
            margin-top: 8px; margin-bottom: 12px; display: none;
            transition: opacity 0.3s ease;
            box-shadow: 0 2px 4px var(--shadow-color-light);
        }
        .message-area.visible { display: block; opacity: 1; }
        .message-area.special {
            color: var(--accent-color); font-size: 1.05em;
            background-color: #f8d7da; border-color: #f5c6cb;
        }

        /* --- Button Styling --- */
        button {
            background-image: linear-gradient(to bottom, var(--secondary-color), #2980b9);
            color: white; border: none; padding: 12px 24px;
            border-radius: 10px; cursor: pointer; font-size: 1.0em;
            font-weight: 600; font-family: 'Poppins', sans-serif;
            transition: background-image 0.3s ease, transform 0.15s ease, box-shadow 0.3s ease;
            box-shadow: 0 3px 8px rgba(52, 152, 219, 0.4);
            text-transform: uppercase; letter-spacing: 0.5px;
        }
        button:hover:not(:disabled) {
            background-image: linear-gradient(to bottom, #3ba0e0, #2f89c0);
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(52, 152, 219, 0.5);
        }
        button:active:not(:disabled) {
            transform: translateY(0px);
            box-shadow: 0 2px 6px rgba(52, 152, 219, 0.3);
        }
        button:disabled {
            background-image: linear-gradient(to bottom, #bdc3c7, #a5acb1);
            cursor: not-allowed; opacity: 0.7;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transform: translateY(0);
        }

        #actie-knoppen {
             display: flex;
             gap: 15px;
             justify-content: center;
             flex-wrap: wrap;
             width: 100%;
             margin-top: 10px;
         }
        #actie-knoppen button {
             width: auto;
             min-width: 150px;
        }


        /* --- Results Styling --- */
         #ronde-resultaten {
            display: none; margin-top: 20px; padding: 20px 25px;
            background-image: linear-gradient(to bottom, var(--primary-color), #2c3e50);
            border-radius: 12px; text-align: left; color: var(--light-text);
            width: 95%; max-width: 480px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
         }
         #ronde-resultaten h3 {
             margin-top: 0; color: var(--light-text); text-align: center;
             margin-bottom: 15px; font-size: 1.4em;
             text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        /* Scores section */
        #ronde-resultaten .score-section {
            margin-bottom: 10px;
            color: #ecf0f1;
            font-size: 1.0em;
            line-height: 1.6;
        }
         #ronde-resultaten .score-section strong.player-name {
             color: #aed6f1;
             font-size: 1.1em;
             display: block;
             margin-bottom: 3px;
         }
        #ronde-resultaten .score-section .throw-history {
            font-size: 0.95em;
            color: #bdc3c7;
            padding-left: 10px;
            display: block;
        }
        #ronde-resultaten .score-section .throw-history span {
            margin-right: 10px;
            display: inline-block;
        }
         #ronde-resultaten .score-section .throw-history .final-throw {
            font-weight: 700;
            color: #ffffff;
         }
        #ronde-resultaten .score-section .throw-history .lowest-score-highlight {
            color: var(--accent-color); /* Red */
            font-weight: bold;
         }
         #ronde-resultaten .score-section .throw-history .special-throw {
            font-style: italic;
            opacity: 0.8;
         }

         /* Actions section */
         #ronde-resultaten .actions-section {
            font-size: 1.05em;
            margin-bottom: 15px;
            color: #ecf0f1;
            line-height: 1.6;
         }
         #ronde-resultaten .actions-section strong {
             color: #aed6f1;
         }

         #ronde-resultaten hr { border: none; border-top: 1px solid rgba(255, 255, 255, 0.2); margin: 15px 0; }
         #ronde-resultaten button {
             margin-top: 15px;
             background-image: linear-gradient(to bottom, var(--secondary-color), #2980b9);
             box-shadow: 0 3px 8px rgba(52, 152, 219, 0.4);
             display: block;
             margin-left: auto;
             margin-right: auto;
        }
        #ronde-resultaten em {
            display: block;
            text-align: center;
            margin-top: 10px;
            font-size: 0.9em;
            color: #bdc3c7;
        }

        /* --- Shake Animation --- */
        @keyframes shake {
            0% { transform: translate(0, 0) rotateX(0) rotateY(0); }
            10% { transform: translate(-8px, -5px) rotateX(-7deg) rotateY(6deg); }
            20% { transform: translate(8px, 5px) rotateX(6deg) rotateY(-7deg); }
            30% { transform: translate(-6px, -3px) rotateX(-5deg) rotateY(4deg); }
            40% { transform: translate(6px, 3px) rotateX(4deg) rotateY(-5deg); }
            50% { transform: translate(-4px, -1px) rotateX(-3deg) rotateY(2deg); }
            60% { transform: translate(4px, 1px) rotateX(2deg) rotateY(-3deg); }
            70% { transform: translate(-2px, 0px) rotateX(-1deg) rotateY(1deg); }
            80% { transform: translate(2px, 0px) rotateX(1deg) rotateY(-1deg); }
            90% { transform: translate(-1px, 0px) rotateX(0deg) rotateY(0deg); }
            100% { transform: translate(0, 0) rotateX(0) rotateY(0); }
        }
        .die.shaking {
            animation: shake 0.35s cubic-bezier(.36,.07,.19,.97) both; /* Faster roll animation */
            transform: translateZ(15px);
        }

        /* --- Responsiveness --- */
         @media (max-width: 500px) {
             :root {
                --dice-size: 100px;
                --dot-size: 18px;
                --dice-padding: 10px;
                --dice-gap: 5px;
                --dice-radius: 18px;
            }
             .container { padding: 20px; gap: 15px; max-width: 95%;}
             .title-container { gap: 8px; margin-bottom: 10px;}
             h1 { font-size: 1.8em; }
             .penguin-logo { height: 35px; }
             .dice-container { gap: 30px; margin-bottom: 20px;}
             #spel-info { flex-direction: column; align-items: center; gap: 5px; }
             #speler-aan-zet { font-size: 1.2em; }
             .score-display { font-size: 1.6em; }
              #actie-knoppen {
                  flex-direction: row;
                  flex-wrap: wrap;
                  justify-content: center;
                  width: 100%;
                  gap: 10px;
              }
              #actie-knoppen button {
                   width: auto;
                   min-width: 120px;
                   padding: 10px 16px;
                   font-size: 0.9em;
               }
             #ronde-resultaten { padding: 15px 20px; }
             #ronde-resultaten h3 { font-size: 1.3em; }
             #ronde-resultaten .score-section,
             #ronde-resultaten .actions-section { font-size: 0.95em; }
              #ronde-resultaten .score-section .throw-history { font-size: 0.9em; }
        }
         @media (max-width: 420px) {
             :root {
                --dice-size: 80px;
                --dot-size: 15px;
                --dice-padding: 8px;
                --dice-gap: 4px;
                --dice-radius: 15px;
            }
             .dice-container { gap: 20px; margin-bottom: 15px; }
         }
         @media (max-width: 360px) {
             :root {
                --dice-size: 70px;
                --dot-size: 13px;
                --dice-padding: 6px;
                --dice-gap: 3px;
                --dice-radius: 12px;
            }
             .dice-container { gap: 15px; }
             #actie-knoppen button {
                  width: 45%;
                  min-width: 0;
             }
         }
    </style>
</head>
<body>
    <div class="title-container">
        <svg class="penguin-logo" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
          <path fill="#2c3e50" d="M50 10 C 30 10, 15 30, 15 50 C 15 80, 35 95, 50 95 C 65 95, 85 80, 85 50 C 85 30, 70 10, 50 10 Z"/>
          <path fill="#ffffff" d="M50 25 C 40 25, 30 40, 30 55 C 30 75, 40 85, 50 85 C 60 85, 70 75, 70 55 C 70 40, 60 25, 50 25 Z"/>
          <ellipse fill="#e67e22" cx="50" cy="75" rx="15" ry="5"/>
          <ellipse fill="#2c3e50" cx="42" cy="45" rx="4" ry="6"/>
          <ellipse fill="#2c3e50" cx="58" cy="45" rx="4" ry="6"/>
          <path fill="#e67e22" d="M 48 60 Q 50 65 52 60 Q 50 58 48 60 Z"/>
          <path fill="#2c3e50" d="M 15 50 C 10 55, 5 70, 10 80 C 20 75, 25 60, 15 50 Z" />
          <path fill="#2c3e50" d="M 85 50 C 90 55, 95 70, 90 80 C 80 75, 75 60, 85 50 Z" />
        </svg>
        <h1>Penguin Mex</h1>
    </div>

    <!-- Setup Fase -->
    <div id="setup-fase" class="container">
        <h2>Spelers</h2>
        <input type="text" id="player-input" placeholder="Naam speler">
        <button id="add-player-btn">Voeg Toe</button>
        <ul id="player-list"></ul>
        <button id="start-game-btn" disabled>Start Spel</button>
        <p><small>Minimaal 2 spelers nodig.</small></p>
    </div>

    <!-- Spel Fase -->
    <div id="spel-fase" class="container">
        <h2 id="ronde-titel">Ronde 1</h2>
        <!-- Elements to hide/show -->
        <div id="spel-info">
             <h3 id="speler-aan-zet">Speler: ...</h3>
             <div id="worp-info">Worp: <span id="worp-teller">0</span> / <span id="max-worpen">3</span></div>
        </div>
        <div class="dice-container">
             <div id="die1" class="die" data-value="0">
                <span class="dot"></span><span class="dot"></span><span class="dot"></span>
                <span class="dot"></span><span class="dot"></span><span class="dot"></span>
                <span class="dot"></span><span class="dot"></span><span class="dot"></span>
            </div>
            <div id="die2" class="die" data-value="0">
                <span class="dot"></span><span class="dot"></span><span class="dot"></span>
                <span class="dot"></span><span class="dot"></span><span class="dot"></span>
                <span class="dot"></span><span class="dot"></span><span class="dot"></span>
            </div>
        </div>
        <div id="score-display" class="score-display">Score: -</div>
        <div id="message-area" class="message-area"></div>
        <!-- Restored action buttons div -->
        <div id="actie-knoppen">
            <button id="main-action-btn" disabled>Gooi</button>
            <button id="show-lowest-btn">Toon Laagste</button>
        </div>
        <!-- End elements to hide/show -->

        <!-- Round Results (Initially hidden) -->
        <div id="ronde-resultaten">
             <h3>Ronde Resultaten</h3>
             <div id="resultaten-acties"></div>
             <hr>
             <div id="resultaten-scores"></div>
             <button id="next-round-btn">Volgende Ronde</button>
         </div>
    </div>

     <!-- Sound Effects (Remember to replace src paths) -->
     <audio id="sound-dice-roll" src="sounds/dice-roll.mp3" preload="auto"></audio>
     <audio id="sound-button-click" src="sounds/button-click.mp3" preload="auto"></audio> <!-- For most buttons -->
     <audio id="sound-hold-die" src="sounds/hold-die.mp3" preload="auto"></audio>
     <audio id="sound-mex" src="sounds/special-mex.mp3" preload="auto"></audio>
     <audio id="sound-special" src="sounds/special-31-32.mp3" preload="auto"></audio>
     <audio id="sound-error" src="sounds/error.mp3" preload="auto"></audio>
     <audio id="sound-round-end" src="sounds/round-end.mp3" preload="auto"></audio>
     <audio id="sound-player-added" src="sounds/player-added.mp3" preload="auto"></audio>
     <audio id="sound-show-lowest" src="sounds/info-ping.mp3" preload="auto"></audio> <!-- Specific sound -->


    <script>
        // --- JavaScript ---

        // Globale Variabelen
        let players = [];
        let playerRoundData = [];
        let currentRound = 0;
        let gameState = 'setup';
        let roundThrowsLimit = 3;
        let mexCountThisRound = 0;
        let roundLowestScore = Infinity;
        let roundLowestPlayerIndices = [];
        let onlyMexRolledSoFar = true;
        let roundTurnOrder = [];
        let currentPlayerIndex = 0;
        let lastRoundLowestIndices = [];
        let overtakenPlayersMap = new Map();
        // Current Turn State
        let throwsThisTurn = 0;
        let currentDice = [0, 0];
        let currentScoreResult = {};
        let heldDice = [false, false];
        let lockedDieIndex = null;
        let allowHolding = false;
        let animationInterval = null;

        // DOM Elementen
        const setupFaseDiv = document.getElementById('setup-fase');
        const spelFaseDiv = document.getElementById('spel-fase');
        const playerInput = document.getElementById('player-input');
        const addPlayerBtn = document.getElementById('add-player-btn');
        const playerListUl = document.getElementById('player-list');
        const startGameBtn = document.getElementById('start-game-btn');
        const rondeTitel = document.getElementById('ronde-titel');
        const spelerAanZetH3 = document.getElementById('speler-aan-zet');
        const die1Div = document.getElementById('die1');
        const die2Div = document.getElementById('die2');
        const scoreDisplayDiv = document.getElementById('score-display');
        const worpTellerSpan = document.getElementById('worp-teller');
        const maxWorpenSpan = document.getElementById('max-worpen');
        const messageAreaDiv = document.getElementById('message-area');
        const mainActionBtn = document.getElementById('main-action-btn'); // Restored main button reference
        const nextRoundBtn = document.getElementById('next-round-btn');
        const showLowestBtn = document.getElementById('show-lowest-btn');
        const rondeResultatenDiv = document.getElementById('ronde-resultaten');
        const resultatenScoresDiv = document.getElementById('resultaten-scores');
        const resultatenActiesDiv = document.getElementById('resultaten-acties');
        const diceContainer = document.querySelector('.dice-container');
        const spelInfoDiv = document.getElementById('spel-info');
        const actieKnoppenDiv = document.getElementById('actie-knoppen');

        // Sound Element References
        const soundDiceRoll = document.getElementById('sound-dice-roll');
        const soundButtonClick = document.getElementById('sound-button-click');
        const soundHoldDie = document.getElementById('sound-hold-die');
        const soundMex = document.getElementById('sound-mex');
        const soundSpecial = document.getElementById('sound-special');
        const soundError = document.getElementById('sound-error');
        const soundRoundEnd = document.getElementById('sound-round-end');
        const soundPlayerAdded = document.getElementById('sound-player-added');
        const soundShowLowest = document.getElementById('sound-show-lowest'); // Added


        // --- Sound Playback Helper ---
        function playSound(audioElement) {
            if (audioElement) {
                audioElement.currentTime = 0;
                audioElement.play().catch(error => {
                    console.error("Error playing sound:", error);
                });
            } else {
                console.warn("Attempted to play a null audio element.");
            }
        }


        // --- Helper Functions ---
        function pluralizeSlok(count) {
            return count === 1 ? "slok" : "slokken";
        }

        function numberToWord(num) {
            const words = ["nul", "één", "twee", "drie", "vier", "vijf", "zes"];
            return words[num] || num.toString();
        }

        // --- Event Listeners ---
        addPlayerBtn.addEventListener('click', addPlayer);
        playerInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addPlayer(); });
        startGameBtn.addEventListener('click', startGame);
        mainActionBtn.addEventListener('click', handleMainButtonClick); // Restored listener
        nextRoundBtn.addEventListener('click', startNewRound);
        showLowestBtn.addEventListener('click', showLowestScoreInfo); // Sound added in function
        die1Div.addEventListener('click', () => handleDieClick(0));
        die2Div.addEventListener('click', () => handleDieClick(1));
        spelFaseDiv.addEventListener('click', handleBackgroundClick);


        // --- Tap Anywhere Logic ---
        function handleBackgroundClick(event) {
            // Only trigger roll if game is in 'playing' state AND main button is enabled
            if (gameState === 'playing' && !mainActionBtn.disabled) {
                const target = event.target;
                const isDie = target.closest('.die');
                const isMainActionButton = target.closest('#main-action-btn'); // Check main button
                const isShowLowestButton = target.closest('#show-lowest-btn');
                const isResultsArea = target.closest('#ronde-resultaten');

                // Trigger roll only if not clicking on interactive elements
                if (!isDie && !isMainActionButton && !isShowLowestButton && !isResultsArea) {
                    console.log("Background click triggered roll");
                    startRollAnimation();
                }
            }
            // Background click no longer advances turn
        }

        // --- Main Button Logic ---
        function handleMainButtonClick() {
             playSound(soundButtonClick); // Play sound on main button click
            if (gameState === 'playing') {
                startRollAnimation(); // Start dice roll
            } else if (gameState === 'turnOver') {
                advanceToNext(); // Move to next player or end round
            }
        }

        // --- Player Setup Functions ---
        function addPlayer() {
            const playerName = playerInput.value.trim();
            if (playerName && players.length < 10) {
                players.push({ name: playerName });
                playerInput.value = '';
                updatePlayerList();
                checkStartGameButton();
                 playSound(soundPlayerAdded);
            } else if (players.length >= 10) {
                 showTemporaryMessage("Max 10 spelers toegestaan.", 'special');
                 playSound(soundError);
            } else {
                 playSound(soundError);
            }
            playerInput.focus();
        }

        function updatePlayerList() {
             playerListUl.innerHTML = '';
            players.forEach(player => {
                const li = document.createElement('li');
                li.textContent = player.name;
                playerListUl.appendChild(li);
            });
        }

        function checkStartGameButton() {
            startGameBtn.disabled = players.length < 2;
        }

        // --- Game Flow Functions ---
        function startGame() {
            if (players.length < 2) return;
            playSound(soundButtonClick);
            lastRoundLowestIndices = [];
            setupFaseDiv.style.display = 'none';
            spelFaseDiv.style.display = 'flex';
            hideMessage();
            startNewRound();
        }

        function startNewRound() {
             playSound(soundButtonClick);
            rondeResultatenDiv.style.display = 'none'; // Hide results
            nextRoundBtn.disabled = true;
            hideMessage();

            // --- Show Game Elements ---
            diceContainer.style.display = 'flex';
            spelInfoDiv.style.display = 'flex';
            scoreDisplayDiv.style.display = 'block';
            actieKnoppenDiv.style.display = 'flex'; // Show container for buttons


            currentRound++;
            rondeTitel.textContent = `Ronde ${currentRound}`;
            roundThrowsLimit = 3;
            mexCountThisRound = 0;
            roundLowestScore = Infinity;
            roundLowestPlayerIndices = [];
            onlyMexRolledSoFar = true;
            overtakenPlayersMap = new Map();
            lockedDieIndex = null;

            // Determine Turn Order (remains the same)
            roundTurnOrder = [];
             if (lastRoundLowestIndices.length > 0) {
                 const startingPlayerIndex = lastRoundLowestIndices[0];
                 roundTurnOrder.push(startingPlayerIndex);
                 let currentIndex = (startingPlayerIndex + 1) % players.length;
                 while (roundTurnOrder.length < players.length) {
                     if (!lastRoundLowestIndices.includes(currentIndex)) {
                         roundTurnOrder.push(currentIndex);
                     }
                      if (currentIndex === startingPlayerIndex && roundTurnOrder.length < players.length) {
                           lastRoundLowestIndices.slice(1).forEach(idx => {
                               if (!roundTurnOrder.includes(idx)) {
                                   roundTurnOrder.push(idx);
                               }
                           });
                          if(roundTurnOrder.length < players.length) {
                              console.error("Error building turn order, potential infinite loop");
                              for(let pIdx = 0; pIdx < players.length; pIdx++) {
                                  if (!roundTurnOrder.includes(pIdx)) roundTurnOrder.push(pIdx);
                              }
                          }
                         break;
                      }
                     currentIndex = (currentIndex + 1) % players.length;
                 }
                  if (roundTurnOrder.length !== players.length) {
                       console.warn("Turn order correction: Adding missing players");
                        for(let pIdx = 0; pIdx < players.length; pIdx++) {
                                  if (!roundTurnOrder.includes(pIdx)) roundTurnOrder.push(pIdx);
                         }
                  }
            } else {
                roundTurnOrder = players.map((_, index) => index);
            }
            console.log("New Round Turn Order (indices):", roundTurnOrder);


            // Reset round data
            playerRoundData = players.map((p, index) => ({
                name: p.name,
                id: index,
                scoreDisplay: null,
                drinksToTake: 0,
                finalThrowValue: null,
                throwsHistory: [],
                drinksGivenFrom31: 0,
                drinksTakenFrom32: 0
            }));

            currentPlayerIndex = 0;
            setupPlayerTurn();
        }

        function setupPlayerTurn() {
            gameState = 'playing';
            const actualPlayerIndex = roundTurnOrder[currentPlayerIndex];
            const currentPlayer = playerRoundData[actualPlayerIndex];
            spelerAanZetH3.textContent = `${currentPlayer.name}`;
            throwsThisTurn = 0;
            currentScoreResult = {};
            currentDice = [0, 0];
            heldDice = [false, false];
            lockedDieIndex = null;
            allowHolding = false;

            updateDiceDisplay();
            scoreDisplayDiv.textContent = "Score: -";
            worpTellerSpan.textContent = throwsThisTurn;
            maxWorpenSpan.textContent = roundThrowsLimit;
            mainActionBtn.disabled = false; // Enable main button
            mainActionBtn.textContent = "Gooi"; // Set text
            showLowestBtn.disabled = false;
            hideMessage();

            // Reset visual state
            die1Div.classList.remove('held', 'clickable', 'shaking');
            die2Div.classList.remove('held', 'clickable', 'shaking');
        }

        // --- Dice Rolling & Animation ---
        function startRollAnimation() {
            playSound(soundDiceRoll);
            mainActionBtn.disabled = true; // Disable main button during roll
            showLowestBtn.disabled = true;
            allowHolding = false;
            die1Div.classList.remove('clickable', 'held');
            die2Div.classList.remove('clickable', 'held');
            hideMessage();

            if (!heldDice[0]) die1Div.classList.add('shaking');
            if (!heldDice[1]) die2Div.classList.add('shaking');

            let animationDuration = 350;
            let intervalTime = 40;
            let elapsed = 0;

            animationInterval = setInterval(() => {
                if (!heldDice[0]) currentDice[0] = getRandomDieValue();
                if (!heldDice[1]) currentDice[1] = getRandomDieValue();
                updateDiceDisplay(true);
                elapsed += intervalTime;
                if (elapsed >= animationDuration) {
                    finishRoll();
                }
            }, intervalTime);
        }

        function finishRoll() {
            clearInterval(animationInterval);
            animationInterval = null;
            die1Div.classList.remove('shaking');
            die2Div.classList.remove('shaking');
            handleRollResultLogic();
        }

        function getRandomDieValue() {
            return Math.floor(Math.random() * 6) + 1;
        }

        function updateDiceDisplay(isAnimating = false) {
            const dieElements = [die1Div, die2Div];
            dieElements.forEach((el, index) => {
                const valueToShow = (heldDice[index] && !isAnimating) ? el.getAttribute('data-value') : currentDice[index].toString();
                el.setAttribute('data-value', valueToShow);
                el.classList.toggle('held', heldDice[index]);
            });
        }

        // --- Roll Result & Score Logic ---
        function handleRollResultLogic() {
            const heldIndexBeforeRoll = heldDice.findIndex(h => h);

            if (heldIndexBeforeRoll !== 0) currentDice[0] = getRandomDieValue();
            if (heldIndexBeforeRoll !== 1) currentDice[1] = getRandomDieValue();
            updateDiceDisplay();

            currentScoreResult = calculateScore(currentDice[0], currentDice[1]);
            scoreDisplayDiv.textContent = `Score: ${currentScoreResult.display}`;
            const actualPlayerIndex = roundTurnOrder[currentPlayerIndex];
            const currentPlayer = playerRoundData[actualPlayerIndex];

             currentPlayer.throwsHistory.push({
                 scoreResult: { ...currentScoreResult }
             });

            if (currentScoreResult.type === 'special') {
                 playSound(soundSpecial);
                 const drinksNow = 1 * Math.pow(2, mexCountThisRound);
                 const slokText = pluralizeSlok(drinksNow);
                 if (currentScoreResult.value === 31) {
                    showTemporaryMessage(`${currentPlayer.name}: 31! Deel ${drinksNow} ${slokText} uit. Gooi opnieuw.`);
                    currentPlayer.drinksGivenFrom31 += drinksNow;
                } else if (currentScoreResult.value === 32) {
                    showTemporaryMessage(`${currentPlayer.name}: 32! Drink ${drinksNow} ${slokText} zelf. Gooi opnieuw.`);
                    currentPlayer.drinksTakenFrom32 += drinksNow;
                }
                heldDice = [false, false];
                lockedDieIndex = null;
                allowHolding = false;
                die1Div.classList.remove('held', 'clickable');
                die2Div.classList.remove('held', 'clickable');
                mainActionBtn.disabled = false; // Re-enable main button
                showLowestBtn.disabled = false;
                return;
            }

            throwsThisTurn++;
            worpTellerSpan.textContent = throwsThisTurn;

             currentPlayer.finalThrowValue = currentScoreResult.value;
             currentPlayer.scoreDisplay = currentScoreResult.display;

             if (currentScoreResult.type === 'normal') {
                 onlyMexRolledSoFar = false;
             }

            heldDice = [false, false]; // Reset logical hold
            die1Div.classList.remove('held'); // Remove visual hold
            die2Div.classList.remove('held');


            if (heldIndexBeforeRoll !== -1) {
                 lockedDieIndex = heldIndexBeforeRoll; // Lock the held die
                 console.log(`Die ${lockedDieIndex} is now locked for next hold.`);
             } else {
                 lockedDieIndex = null;
                 console.log("No die locked for next hold.");
             }


            if (currentScoreResult.type === 'mex') {
                 playSound(soundMex);
                 mexCountThisRound++;
                 const multiplier = Math.pow(2, mexCountThisRound);
                 let mexMsg = `MEX! ${currentPlayer.name} stopt direct.`;
                 if (currentPlayerIndex === 0 && throwsThisTurn < roundThrowsLimit) {
                     roundThrowsLimit = throwsThisTurn;
                     maxWorpenSpan.textContent = roundThrowsLimit;
                     mexMsg += ` Nieuwe limiet: ${roundThrowsLimit} worp${roundThrowsLimit === 1 ? '' : 'en'}.`;
                 }
                 mexMsg += ` ${pluralizeSlok(2)} x${multiplier}!`;
                 showTemporaryMessage(mexMsg, 'special');
                 endPlayerTurn();
                 return;
            }

            if (throwsThisTurn >= roundThrowsLimit) {
                 endPlayerTurn();
            } else {
                 mainActionBtn.disabled = false; // Re-enable main button
                 showLowestBtn.disabled = false;
                 allowHolding = true;

                 const dieElements = [die1Div, die2Div];
                 dieElements.forEach((dieEl) => {
                     dieEl.classList.add('clickable'); // Always add clickable class visually
                 });
                 console.log("Turn continues. Both dice visually clickable.");
            }
        }

        function calculateScore(d1, d2) {
            if (d1 === 0 || d2 === 0) return { value: 0, display: "-", type: 'none'};
            if ((d1 === 2 && d2 === 1) || (d1 === 1 && d2 === 2)) return { value: 1000, display: "Mex", type: 'mex' };
            if ((d1 === 3 && d2 === 1) || (d1 === 1 && d2 === 3)) return { value: 31, display: "31", type: 'special' };
            if ((d1 === 3 && d2 === 2) || (d1 === 2 && d2 === 3)) return { value: 32, display: "32", type: 'special' };
            if (d1 === d2) return { value: d1 * 100, display: `${d1}${d1}`, type: 'normal' };
            const high = Math.max(d1, d2);
            const low = Math.min(d1, d2);
            return { value: high * 10 + low, display: `${high}${low}`, type: 'normal' };
        }

        // --- Die Holding Logic ---
        function handleDieClick(index) {
            if (!allowHolding) return;

            const dieElement = document.getElementById(`die${index + 1}`);
            const dieValue = currentDice[index];
            const otherIndex = 1 - index;

            if (index === lockedDieIndex) {
                showTemporaryMessage(`Deze dobbelsteen (${dieValue}) moet nu gooien (was vastgehouden).`);
                 playSound(soundError);
                return;
            }

            if (dieValue > 3) {
                 showTemporaryMessage(`Je kunt ${dieValue} niet vasthouden (alleen 1, 2 of 3).`);
                 playSound(soundError);
                 return;
            }

            if (!heldDice[index] && heldDice[otherIndex]) {
                 showTemporaryMessage("Je kunt maar één dobbelsteen vasthouden.");
                 playSound(soundError);
                 return;
            }

            heldDice[index] = !heldDice[index];
            dieElement.classList.toggle('held', heldDice[index]); // Only toggle visual held class

             if (heldDice[index]) {
                 playSound(soundHoldDie);
                console.log(`Held die ${index}.`);
            } else {
                console.log(`Released die ${index}.`);
            }
        }


        // --- Turn & Round Ending Logic ---
        function endPlayerTurn() {
            gameState = 'turnOver';
            mainActionBtn.textContent = 'Volgende Speler'; // Set button text
            mainActionBtn.disabled = false; // Ensure button is clickable to advance
            showLowestBtn.disabled = true;
            allowHolding = false;
            die1Div.classList.remove('shaking', 'held', 'clickable'); // Clean UI
            die2Div.classList.remove('shaking', 'held', 'clickable');
            heldDice = [false, false];
            lockedDieIndex = null;

            const actualPlayerIndex = roundTurnOrder[currentPlayerIndex];
            const finalScoreValue = playerRoundData[actualPlayerIndex].finalThrowValue;
            const currentPlayerName = playerRoundData[actualPlayerIndex].name;
            const currentScoreDisplay = playerRoundData[actualPlayerIndex].scoreDisplay;

            // --- Lowest Score & Overtake Logic ---
            if (finalScoreValue !== null && finalScoreValue !== 31 && finalScoreValue !== 32) {
                 const scoreToCompare = finalScoreValue;
                 const canMexBeLowest = onlyMexRolledSoFar && scoreToCompare === 1000;

                 if (scoreToCompare < roundLowestScore || (canMexBeLowest && roundLowestScore === Infinity)) {
                     roundLowestScore = scoreToCompare;
                     roundLowestPlayerIndices = [actualPlayerIndex];
                     console.log(`New lowest score: ${currentScoreDisplay} by ${currentPlayerName}`);
                 }
                 else if (scoreToCompare === roundLowestScore) {
                     if (!roundLowestPlayerIndices.includes(actualPlayerIndex)) {
                         const previousLowestPlayerIndex = roundLowestPlayerIndices[0];

                         const drinksForThisOvertake = 1 * Math.pow(2, mexCountThisRound);
                         const currentOvertakeDrinks = overtakenPlayersMap.get(previousLowestPlayerIndex) || 0;
                         overtakenPlayersMap.set(previousLowestPlayerIndex, currentOvertakeDrinks + drinksForThisOvertake);
                         console.log(`Player ${previousLowestPlayerIndex} overtaken, owes ${overtakenPlayersMap.get(previousLowestPlayerIndex)} drinks`);

                         roundLowestPlayerIndices = [actualPlayerIndex]; // Current player takes over

                         showTemporaryMessage(`${currentPlayerName} (${currentScoreDisplay}) evenaart laagste! ${playerRoundData[previousLowestPlayerIndex]?.name || 'Iemand'} moet extra drinken!`, 'special');
                         console.log(`${currentPlayerName} overtakes/ties lowest score ${currentScoreDisplay} from ${playerRoundData[previousLowestPlayerIndex]?.name || 'Previous'}`);
                     }
                 }
            }

            // --- End Turn Message ---
            if (!messageAreaDiv.classList.contains('visible')) {
                 const displayScore = currentScoreDisplay || "Geen score";
                 // Keep message simple, button handles advance
                showTemporaryMessage(`Beurt van ${currentPlayerName} (${displayScore}) is klaar.`);
            }
             // State is set at the top of the function now
        }


        function advanceToNext() {
             // Called by the main action button when in 'turnOver' state
             hideMessage(); // Hide the "turn over" message
            currentPlayerIndex++;
            if (currentPlayerIndex < roundTurnOrder.length) {
                setupPlayerTurn();
            } else {
                endRound();
            }
        }

        function endRound() {
            gameState = 'roundOver';
            mainActionBtn.disabled = true; // Disable the main button
            mainActionBtn.textContent = "Ronde Klaar"; // Update text
            showLowestBtn.disabled = true;
            hideMessage();
            playSound(soundRoundEnd);

            // --- Hide Game Elements ---
            diceContainer.style.display = 'none';
            spelInfoDiv.style.display = 'none';
            scoreDisplayDiv.style.display = 'none';
            actieKnoppenDiv.style.display = 'none'; // Hide the button container

            let drinksMultiplier = Math.pow(2, mexCountThisRound);
            let actionMessages = [];
            let scoreHTML = "<strong>Worpgeschiedenis:</strong><br>";
            let actualRoundLowestNormalScoreValue = Infinity;
            let lowestScoreDisplayValue = null;

             // --- Calculate Drinks & Actions ---
            // 1. Process 31/32 drinks
            playerRoundData.forEach((data) => {
                 if (data.drinksGivenFrom31 > 0) actionMessages.push(`<strong>${data.name}</strong> deelt ${data.drinksGivenFrom31} ${pluralizeSlok(data.drinksGivenFrom31)} uit (door 31).`);
                 if (data.drinksTakenFrom32 > 0) actionMessages.push(`<strong>${data.name}</strong> drinkt ${data.drinksTakenFrom32} ${pluralizeSlok(data.drinksTakenFrom32)} zelf (door 32).`);
             });

            // 2. Process Accumulated Overtake Drinks
            if (overtakenPlayersMap.size > 0) {
                overtakenPlayersMap.forEach((totalOvertakeDrinks, playerIndex) => {
                    if (playerRoundData[playerIndex]) {
                        const overtakenPlayerName = playerRoundData[playerIndex].name;
                        const overtakenScoreApprox = playerRoundData[playerIndex].scoreDisplay || '?';
                        actionMessages.push(`<strong>${overtakenPlayerName}</strong> drinkt ${totalOvertakeDrinks} ${pluralizeSlok(totalOvertakeDrinks)} (score ${overtakenScoreApprox} ingehaald!).`);
                        playerRoundData[playerIndex].drinksToTake += totalOvertakeDrinks;
                    } else {
                         console.error("Overtaken player index out of bounds:", playerIndex);
                    }
                });
            }

            // 3. Process Lowest Score Penalty
            if (roundLowestPlayerIndices.length > 0 && roundLowestScore !== Infinity) {
                 const drinksForLowest = 1 * drinksMultiplier;
                 const lowestPlayersForPenalty = [];
                 const lowestPlayerIndicesForPenalty = [];

                 let displayScoreForMsg = "";
                  if (roundLowestScore === 1000) {
                      displayScoreForMsg = "Mex";
                  } else {
                       for(let i = 0; i < playerRoundData.length; i++) {
                           const pData = playerRoundData[i];
                           const finalThrow = pData.throwsHistory.slice().reverse().find(t => t.scoreResult.type !== 'special');
                           if(finalThrow && finalThrow.scoreResult.type === 'normal' && finalThrow.scoreResult.value === roundLowestScore) {
                               lowestScoreDisplayValue = finalThrow.scoreResult.display;
                               displayScoreForMsg = lowestScoreDisplayValue;
                               break;
                           }
                       }
                       if (!displayScoreForMsg) displayScoreForMsg = roundLowestScore.toString();
                   }


                 roundLowestPlayerIndices.forEach(index => {
                     if (!overtakenPlayersMap.has(index)) {
                         if (playerRoundData[index]) {
                             playerRoundData[index].drinksToTake += drinksForLowest;
                             lowestPlayersForPenalty.push(`<strong>${playerRoundData[index].name}</strong>`);
                             lowestPlayerIndicesForPenalty.push(index);
                         }
                     }
                 });

                 if (lowestPlayersForPenalty.length > 0) {
                     if (lowestPlayersForPenalty.length === 1) {
                         actionMessages.push(`${lowestPlayersForPenalty[0]} heeft de laagste score (${displayScoreForMsg}) en drinkt ${drinksForLowest} ${pluralizeSlok(drinksForLowest)}.`);
                     } else {
                         actionMessages.push(`Gelijkspel laagste score (${displayScoreForMsg}): ${lowestPlayersForPenalty.join(', ')} drinken elk ${drinksForLowest} ${pluralizeSlok(drinksForLowest)}.`);
                     }
                 }
            }
            else if (roundLowestScore === Infinity && overtakenPlayersMap.size === 0) {
                 actionMessages.push("Geen geldige laagste score bepaald deze ronde.");
            }


            // --- Build Action Display HTML ---
             let actionsHTML = "<strong class='actions-section'>Acties & Drankjes (Einde Ronde):</strong><br>";
             actionsHTML += '<div class="actions-section">';
             actionsHTML += actionMessages.length > 0 ? actionMessages.join('<br>') : "Geen speciale acties deze ronde.";
             if (mexCountThisRound > 0) {
                  const mexWord = numberToWord(mexCountThisRound);
                 actionsHTML += `<br><em>(${pluralizeSlok(2)} voor laagste/overname x${drinksMultiplier} door ${mexWord} Mex worp${mexCountThisRound > 1 ? 'en' : ''})</em>`;
             }
             actionsHTML += '</div>';
            resultatenActiesDiv.innerHTML = actionsHTML; // RENDER ACTIONS FIRST


            // --- Build and Render Score History HTML (in Turn Order) ---
            for (let i = 0; i < roundTurnOrder.length; i++) {
                 const actualPlayerIndex = roundTurnOrder[i];
                 const data = playerRoundData[actualPlayerIndex];

                 scoreHTML += `<div class="score-section">`;
                 scoreHTML += `<strong class="player-name">${data.name}:</strong>`;
                 scoreHTML += `<span class="throw-history" data-player-index="${data.id}">`; // Use original ID

                 let finalThrowIndex = -1;
                 if (data.throwsHistory.length > 0) {
                     for(let j = data.throwsHistory.length - 1; j >= 0; j--) {
                         if(data.throwsHistory[j].scoreResult.type !== 'special') {
                             finalThrowIndex = j;
                             break;
                         }
                     }

                     data.throwsHistory.forEach((throwData, index) => {
                         const scoreStr = throwData.scoreResult.display;
                         let classes = [];
                         if (index === finalThrowIndex) classes.push('final-throw');
                         if (throwData.scoreResult.type === 'special') classes.push('special-throw');
                         scoreHTML += `<span class="${classes.join(' ')}" data-score-value="${throwData.scoreResult.value}" data-score-type="${throwData.scoreResult.type}">${scoreStr}</span>`;
                     });
                 } else {
                     scoreHTML += ` (Geen geldige worpen)`;
                 }
                 scoreHTML += `</span></div>`;
             }
            resultatenScoresDiv.innerHTML = scoreHTML; // RENDER HISTORY SECOND


             // --- Highlight Lowest Scores in Rendered History ---
             if (lowestScoreDisplayValue !== null && roundLowestScore !== 1000) {
                  roundLowestPlayerIndices.forEach(playerIndex => {
                      const playerHistorySpan = resultatenScoresDiv.querySelector(`.throw-history[data-player-index="${playerIndex}"]`);
                      if (playerHistorySpan) {
                          const finalThrowSpan = playerHistorySpan.querySelector('.final-throw');
                          if (finalThrowSpan && finalThrowSpan.textContent === lowestScoreDisplayValue && finalThrowSpan.dataset.scoreType === 'normal') {
                              finalThrowSpan.classList.add('lowest-score-highlight');
                          }
                      }
                  });
             }


            // --- Prepare for Next Round ---
            lastRoundLowestIndices = roundLowestPlayerIndices.length > 0 ? [...roundLowestPlayerIndices] : [];

            // Show results container and enable next round button
            rondeResultatenDiv.style.display = 'block';
            nextRoundBtn.disabled = false;
        }


        // --- Utility Functions ---
        function showLowestScoreInfo() {
             playSound(soundShowLowest); // Play specific sound
             if (roundLowestScore === Infinity) {
                showTemporaryMessage("Nog geen laagste score bepaald in deze ronde.");
            } else {
                 let lowestScoreDisplay;
                 if (roundLowestScore === 1000) {
                     lowestScoreDisplay = "Mex";
                 } else if (roundLowestPlayerIndices.length > 0 && playerRoundData[roundLowestPlayerIndices[0]]) {
                     const firstLowestPlayer = playerRoundData[roundLowestPlayerIndices[0]];
                     const lastValidThrow = firstLowestPlayer.throwsHistory.slice().reverse().find(t => t.scoreResult.type !== 'special');
                      if(lastValidThrow && lastValidThrow.scoreResult.value === roundLowestScore){
                          lowestScoreDisplay = lastValidThrow.scoreResult.display;
                      } else {
                           lowestScoreDisplay = roundLowestScore.toString();
                      }
                 } else {
                      lowestScoreDisplay = roundLowestScore.toString();
                 }

                 const lowestPlayerNames = roundLowestPlayerIndices.map(i => playerRoundData[i]?.name || 'Onbekend').join(', ');
                showTemporaryMessage(`Huidige laagste score: ${lowestScoreDisplay} (van ${lowestPlayerNames})`);
            }
        }

        function showTemporaryMessage(msg, type = 'info') {
            messageAreaDiv.innerHTML = msg;
            messageAreaDiv.className = 'message-area visible';
            if (type === 'special') {
                messageAreaDiv.classList.add('special');
            }
        }

        function hideMessage() {
            messageAreaDiv.className = 'message-area';
        }

        // --- Initialisation ---
        checkStartGameButton();
        hideMessage();

    </script>

</body>
</html>