<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="styles/style.css">
    <title>Penguin Mex</title>

</head>
<body>
    <div class="title-container">
        <svg class="penguin-logo" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
          <path fill="#2c3e50" d="M50 10 C 30 10, 15 30, 15 50 C 15 80, 35 95, 50 95 C 65 95, 85 80, 85 50 C 85 30, 70 10, 50 10 Z"/>
          <path fill="#ffffff" d="M50 25 C 40 25, 30 40, 30 55 C 30 75, 40 85, 50 85 C 60 85, 70 75, 70 55 C 70 40, 60 25, 50 25 Z"/>
          <ellipse fill="#e67e22" cx="50" cy="75" rx="15" ry="5"/>
          <ellipse fill="#2c3e50" cx="42" cy="45" rx="4" ry="6"/>
          <ellipse fill="#2c3e50" cx="58" cy="45" rx="4" ry="6"/>
          <path fill="#e67e22" d="M 48 60 Q 50 65 52 60 Q 50 58 48 60 Z"/>
          <path fill="#2c3e50" d="M 15 50 C 10 55, 5 70, 10 80 C 20 75, 25 60, 15 50 Z" />
          <path fill="#2c3e50" d="M 85 50 C 90 55, 95 70, 90 80 C 80 75, 75 60, 85 50 Z" />
        </svg>
        <h1>Penguin Mex</h1>
    </div>

    <!-- Setup Fase -->
    <div id="setup-fase" class="container">
        <h2>Spelers</h2>
        <input type="text" id="player-input" placeholder="Naam speler">
        <button id="add-player-btn">Voeg Toe</button>
        <ul id="player-list"></ul>
        <button id="start-game-btn" disabled>Start Spel</button>
        <p><small>Minimaal 2 spelers nodig.</small></p>
    </div>

    <!-- Spel Fase -->
    <div id="spel-fase" class="container">
        <h2 id="ronde-titel">Ronde 1</h2>
        <!-- Elements to hide/show -->
        <div id="spel-info">
             <h3 id="speler-aan-zet">Speler: ...</h3>
             <div id="worp-info">Worp: <span id="worp-teller">0</span> / <span id="max-worpen">3</span></div>
        </div>
        <div class="dice-container">
             <div id="die1" class="die" data-value="0">
                <span class="dot"></span><span class="dot"></span><span class="dot"></span>
                <span class="dot"></span><span class="dot"></span><span class="dot"></span>
                <span class="dot"></span><span class="dot"></span><span class="dot"></span>
            </div>
            <div id="die2" class="die" data-value="0">
                <span class="dot"></span><span class="dot"></span><span class="dot"></span>
                <span class="dot"></span><span class="dot"></span><span class="dot"></span>
                <span class="dot"></span><span class="dot"></span><span class="dot"></span>
            </div>
        </div>
        <div id="score-display" class="score-display">Score: -</div>
        <div id="message-area" class="message-area"></div>
        <!-- Restored action buttons div -->
        <div id="actie-knoppen">
            <button id="main-action-btn" disabled>Gooi</button>
            <button id="show-lowest-btn">Toon Laagste</button>
        </div>
        <!-- End elements to hide/show -->

        <!-- Round Results (Initially hidden) -->
        <div id="ronde-resultaten">
             <div id="lowest-score-announcement"></div> <!-- ADDED: For lowest score message -->
             <h3>Resultaten</h3>
             <div id="resultaten-acties"></div>
             <hr>
             <div id="resultaten-scores"></div>
             <button id="next-round-btn">Volgende Ronde</button>
         </div>
    </div>

     <!-- Sound Effects (Remember to replace src paths) -->
     <audio id="sound-dice-roll" src="sounds/DiceRoll.wav" preload="auto"></audio>
     <audio id="sound-button-click" src="sounds/button-click.mp3" preload="auto"></audio> <!-- For most buttons -->
     <audio id="sound-hold-die" src="sounds/hold-die.mp3" preload="auto"></audio>
     <audio id="sound-mex" src="sounds/special-mex.mp3" preload="auto"></audio>
     <audio id="sound-special" src="sounds/special-31-32.mp3" preload="auto"></audio>
     <audio id="sound-error" src="sounds/error.mp3" preload="auto"></audio>
     <audio id="sound-round-end" src="sounds/round-end.mp3" preload="auto"></audio>
     <audio id="sound-player-added" src="sounds/player-added.mp3" preload="auto"></audio>
     <audio id="sound-show-lowest" src="sounds/ShowLowestScore.wav"></audio> <!-- Specific sound -->


    <script>
        // --- JavaScript ---

        // Globale Variabelen
        let players = [];
        let playerRoundData = [];
        let currentRound = 0;
        let gameState = 'setup';
        let roundThrowsLimit = 3;
        let mexCountThisRound = 0;
        let roundLowestScore = Infinity;
        let roundLowestPlayerIndices = [];
        let onlyMexRolledSoFar = true;
        let roundTurnOrder = [];
        let currentPlayerIndex = 0;
        let lastRoundLowestIndices = [];
        let overtakenPlayersMap = new Map();
        // Current Turn State
        let throwsThisTurn = 0;
        let currentDice = [0, 0];
        let currentScoreResult = {};
        let heldDice = [false, false];
        let lockedDieIndex = null;
        let allowHolding = false;
        let animationInterval = null;

        // DOM Elementen
        
        const spelFaseDiv = document.getElementById('spel-fase');
        const playerInput = document.getElementById('player-input');
        const addPlayerBtn = document.getElementById('add-player-btn');
        const playerListUl = document.getElementById('player-list');
        const startGameBtn = document.getElementById('start-game-btn');
        const rondeTitel = document.getElementById('ronde-titel');
        const spelerAanZetH3 = document.getElementById('speler-aan-zet');
        const die1Div = document.getElementById('die1');
        const die2Div = document.getElementById('die2');
        const scoreDisplayDiv = document.getElementById('score-display');
        const worpTellerSpan = document.getElementById('worp-teller');
        const maxWorpenSpan = document.getElementById('max-worpen');
        const messageAreaDiv = document.getElementById('message-area');
        const mainActionBtn = document.getElementById('main-action-btn'); // Restored main button reference
        const nextRoundBtn = document.getElementById('next-round-btn');
        const showLowestBtn = document.getElementById('show-lowest-btn');
        const rondeResultatenDiv = document.getElementById('ronde-resultaten');
        const resultatenScoresDiv = document.getElementById('resultaten-scores');
        const resultatenActiesDiv = document.getElementById('resultaten-acties');
        const diceContainer = document.querySelector('.dice-container');
        const spelInfoDiv = document.getElementById('spel-info');
        const actieKnoppenDiv = document.getElementById('actie-knoppen');

        // Sound Element References
        const soundDiceRoll = document.getElementById('sound-dice-roll');
        const soundButtonClick = document.getElementById('sound-button-click');
        const soundHoldDie = document.getElementById('sound-hold-die');
        const soundMex = document.getElementById('sound-mex');
        const soundSpecial = document.getElementById('sound-special');
        const soundError = document.getElementById('sound-error');
        const soundRoundEnd = document.getElementById('sound-round-end');
        const soundPlayerAdded = document.getElementById('sound-player-added');
        const soundShowLowest = document.getElementById('sound-show-lowest'); // Added


        // --- Sound Playback Helper ---
        function playSound(audioElement) {
            if (audioElement) {
                audioElement.currentTime = 0;
                audioElement.play().catch(error => {
                    console.error("Error playing sound:", error);
                });
            } else {
                console.warn("Attempted to play a null audio element.");
            }
        }


        // --- Helper Functions ---
        function pluralizeSlok(count) {
            return count === 1 ? "slok" : "slokken";
        }

        function numberToWord(num) {
            const words = ["nul", "één", "twee", "drie", "vier", "vijf", "zes"];
            return words[num] || num.toString();
        }

        // --- Event Listeners ---
        addPlayerBtn.addEventListener('click', addPlayer);
        playerInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addPlayer(); });
        startGameBtn.addEventListener('click', startGame);
        mainActionBtn.addEventListener('click', handleMainButtonClick); // Restored listener
        nextRoundBtn.addEventListener('click', startNewRound);
        showLowestBtn.addEventListener('click', showLowestScoreInfo); // Sound added in function
        die1Div.addEventListener('click', () => handleDieClick(0));
        die2Div.addEventListener('click', () => handleDieClick(1));

 
        // --- Main Button Logic ---
        function handleMainButtonClick() {
             playSound(soundButtonClick); // Play sound on main button click
            if (gameState === 'playing') {
                startRollAnimation(); // Start dice roll
            } else if (gameState === 'turnOver') {
                advanceToNext(); // Move to next player or end round
            }
        }

        // --- Player Setup Functions ---
        function addPlayer() {
            const playerName = playerInput.value.trim();
            if (playerName && players.length < 10) {
                players.push({ name: playerName });
                playerInput.value = '';
                updatePlayerList();
                checkStartGameButton();
                 playSound(soundPlayerAdded);
            } else if (players.length >= 10) {
                 showTemporaryMessage("Max 10 spelers toegestaan.", 'special');
                 playSound(soundError);
            } else {
                 playSound(soundError);
            }
            playerInput.focus();
        }

        function updatePlayerList() {
             playerListUl.innerHTML = '';
            players.forEach(player => {
                const li = document.createElement('li');
                li.textContent = player.name;
                playerListUl.appendChild(li);
            });
        }

        function checkStartGameButton() {
            startGameBtn.disabled = players.length < 2;
        }

        // --- Game Flow Functions ---
        function startGame() {
            if (players.length < 2) return;
            playSound(soundButtonClick);
            lastRoundLowestIndices = [];
            setupFaseDiv.style.display = 'none';
            spelFaseDiv.style.display = 'flex';
            hideMessage();
            startNewRound();
        }

        function startNewRound() {
             playSound(soundButtonClick);
             // --- START: Clear announcement and class ---
             const announcementDiv = document.getElementById('lowest-score-announcement');
             if (announcementDiv) announcementDiv.textContent = '';
             rondeResultatenDiv.classList.remove('showing-results');
             // --- END: Clear announcement and class ---
            rondeResultatenDiv.style.display = 'none'; // Hide results (existing line)
            nextRoundBtn.disabled = true;
            hideMessage();

            // --- Show Game Elements ---
            diceContainer.style.display = 'flex';
            spelInfoDiv.style.display = 'flex';
            scoreDisplayDiv.style.display = 'block';
            actieKnoppenDiv.style.display = 'flex'; // Show container for buttons


            currentRound++;
            rondeTitel.textContent = `Ronde ${currentRound}`;
            roundThrowsLimit = 3;
            mexCountThisRound = 0;
            roundLowestScore = Infinity;
            roundLowestPlayerIndices = [];
            onlyMexRolledSoFar = true;
            overtakenPlayersMap = new Map();
            lockedDieIndex = null;

            // Determine Turn Order (remains the same)
            roundTurnOrder = [];
             if (lastRoundLowestIndices.length > 0) {
                 const startingPlayerIndex = lastRoundLowestIndices[0];
                 roundTurnOrder.push(startingPlayerIndex);
                 let currentIndex = (startingPlayerIndex + 1) % players.length;
                 while (roundTurnOrder.length < players.length) {
                     if (!lastRoundLowestIndices.includes(currentIndex)) {
                         roundTurnOrder.push(currentIndex);
                     }
                      if (currentIndex === startingPlayerIndex && roundTurnOrder.length < players.length) {
                           lastRoundLowestIndices.slice(1).forEach(idx => {
                               if (!roundTurnOrder.includes(idx)) {
                                   roundTurnOrder.push(idx);
                               }
                           });
                          if(roundTurnOrder.length < players.length) {
                              console.error("Error building turn order, potential infinite loop");
                              for(let pIdx = 0; pIdx < players.length; pIdx++) {
                                  if (!roundTurnOrder.includes(pIdx)) roundTurnOrder.push(pIdx);
                              }
                          }
                         break;
                      }
                     currentIndex = (currentIndex + 1) % players.length;
                 }
                  if (roundTurnOrder.length !== players.length) {
                       console.warn("Turn order correction: Adding missing players");
                        for(let pIdx = 0; pIdx < players.length; pIdx++) {
                                  if (!roundTurnOrder.includes(pIdx)) roundTurnOrder.push(pIdx);
                         }
                  }
            } else {
                roundTurnOrder = players.map((_, index) => index);
            }
            console.log("New Round Turn Order (indices):", roundTurnOrder);


            // Reset round data
            playerRoundData = players.map((p, index) => ({
                name: p.name,
                id: index,
                scoreDisplay: null,
                drinksToTake: 0,
                finalThrowValue: null,
                throwsHistory: [],
                drinksGivenFrom31: 0,
                drinksTakenFrom32: 0
            }));

            currentPlayerIndex = 0;
            setupPlayerTurn();
        }

        function setupPlayerTurn() {
            gameState = 'playing';
            const actualPlayerIndex = roundTurnOrder[currentPlayerIndex];
            const currentPlayer = playerRoundData[actualPlayerIndex];
            spelerAanZetH3.textContent = `${currentPlayer.name}`;
            throwsThisTurn = 0;
            currentScoreResult = {};
            currentDice = [0, 0];
            heldDice = [false, false];
            lockedDieIndex = null;
            allowHolding = false;

            updateDiceDisplay();
            scoreDisplayDiv.textContent = "Score: -";
            worpTellerSpan.textContent = throwsThisTurn;
            maxWorpenSpan.textContent = roundThrowsLimit;
            mainActionBtn.disabled = false; // Enable main button
            mainActionBtn.textContent = "Gooi"; // Set text
            showLowestBtn.disabled = false;
            hideMessage();

            // Reset visual state
            die1Div.classList.remove('held', 'clickable', 'shaking');
            die2Div.classList.remove('held', 'clickable', 'shaking');
        }


        function finishRoll() {
            clearInterval(animationInterval);
            animationInterval = null;
            die1Div.classList.remove('shaking');
            die2Div.classList.remove('shaking');
            handleRollResultLogic();
        }

        function getRandomDieValue() {
            return Math.floor(Math.random() * 6) + 1;
        }

        function updateDiceDisplay(isAnimating = false) {
            const dieElements = [die1Div, die2Div];
            dieElements.forEach((el, index) => {
                const valueToShow = (heldDice[index] && !isAnimating) ? el.getAttribute('data-value') : currentDice[index].toString();
                el.setAttribute('data-value', valueToShow);
                el.classList.toggle('held', heldDice[index]);
            });
        }

        // --- Roll Result & Score Logic ---
        function handleRollResultLogic() {
            const heldIndexBeforeRoll = heldDice.findIndex(h => h);

            if (heldIndexBeforeRoll !== 0) currentDice[0] = getRandomDieValue();
            if (heldIndexBeforeRoll !== 1) currentDice[1] = getRandomDieValue();
            updateDiceDisplay();

            currentScoreResult = calculateScore(currentDice[0], currentDice[1]);
            scoreDisplayDiv.textContent = `Score: ${currentScoreResult.display}`;
            const actualPlayerIndex = roundTurnOrder[currentPlayerIndex];
            const currentPlayer = playerRoundData[actualPlayerIndex];

             currentPlayer.throwsHistory.push({
                 scoreResult: { ...currentScoreResult }
             });

            if (currentScoreResult.type === 'special') {
                 playSound(soundSpecial);
                 const drinksNow = 1 * Math.pow(2, mexCountThisRound);
                 const slokText = pluralizeSlok(drinksNow);
                 if (currentScoreResult.value === 31) {
                    showTemporaryMessage(`31! Deel ${drinksNow} ${slokText} uit.`);
                    currentPlayer.drinksGivenFrom31 += drinksNow;
                } else if (currentScoreResult.value === 32) {
                    showTemporaryMessage(`32! Drink ${drinksNow} ${slokText} zelf.`);
                    currentPlayer.drinksTakenFrom32 += drinksNow;
                }
                heldDice = [false, false];
                lockedDieIndex = null;
                allowHolding = false;
                die1Div.classList.remove('held', 'clickable');
                die2Div.classList.remove('held', 'clickable');
                mainActionBtn.disabled = false; // Re-enable main button
                showLowestBtn.disabled = false;
                return;
            }

            throwsThisTurn++;
            worpTellerSpan.textContent = throwsThisTurn;

             currentPlayer.finalThrowValue = currentScoreResult.value;
             currentPlayer.scoreDisplay = currentScoreResult.display;

             if (currentScoreResult.type === 'normal') {
                 onlyMexRolledSoFar = false;
             }

            heldDice = [false, false]; // Reset logical hold
            die1Div.classList.remove('held'); // Remove visual hold
            die2Div.classList.remove('held');


            if (heldIndexBeforeRoll !== -1) {
                 lockedDieIndex = heldIndexBeforeRoll; // Lock the held die
                 console.log(`Die ${lockedDieIndex} is now locked for next hold.`);
             } else {
                 lockedDieIndex = null;
                 console.log("No die locked for next hold.");
             }


            if (currentScoreResult.type === 'mex') {
                 playSound(soundMex);
                 mexCountThisRound++;
                 const multiplier = Math.pow(2, mexCountThisRound);
                 let mexMsg = `MEX! ${currentPlayer.name} stopt direct.`;
                 if (currentPlayerIndex === 0 && throwsThisTurn < roundThrowsLimit) {
                     roundThrowsLimit = throwsThisTurn;
                     maxWorpenSpan.textContent = roundThrowsLimit;
                     mexMsg += ` Nieuwe limiet: ${roundThrowsLimit} worp${roundThrowsLimit === 1 ? '' : 'en'}.`;
                 }
                 mexMsg += ` ${pluralizeSlok(2)} x${multiplier}!`;
                 showTemporaryMessage(mexMsg, 'special');
                 endPlayerTurn();
                 return;
            }

            if (throwsThisTurn >= roundThrowsLimit) {
                 endPlayerTurn();
            } else {
                 mainActionBtn.disabled = false; // Re-enable main button
                 showLowestBtn.disabled = false;
                 allowHolding = true;

                 const dieElements = [die1Div, die2Div];
                 dieElements.forEach((dieEl) => {
                     dieEl.classList.add('clickable'); // Always add clickable class visually
                 });
                 console.log("Turn continues. Both dice visually clickable.");
            }
        }

        function calculateScore(d1, d2) {
            if (d1 === 0 || d2 === 0) return { value: 0, display: "-", type: 'none'};
            if ((d1 === 2 && d2 === 1) || (d1 === 1 && d2 === 2)) return { value: 1000, display: "Mex", type: 'mex' };
            if ((d1 === 3 && d2 === 1) || (d1 === 1 && d2 === 3)) return { value: 31, display: "31", type: 'special' };
            if ((d1 === 3 && d2 === 2) || (d1 === 2 && d2 === 3)) return { value: 32, display: "32", type: 'special' };
            if (d1 === d2) return { value: d1 * 100, display: `${d1}00`, type: 'normal' };
            const high = Math.max(d1, d2);
            const low = Math.min(d1, d2);
            return { value: high * 10 + low, display: `${high}${low}`, type: 'normal' };
        }

        // --- Die Holding Logic ---
        function handleDieClick(index) {
            if (!allowHolding) return;

            const dieElement = document.getElementById(`die${index + 1}`);
            const dieValue = currentDice[index];
            const otherIndex = 1 - index;

            if (index === lockedDieIndex) {
                showTemporaryMessage(`Je mag een dobbelsteen maar één keer vasthouden`);
                 playSound(soundError);
                return;
            }

            if (dieValue > 3) {
                 showTemporaryMessage(`Je kunt ${dieValue} niet vasthouden`);
                 playSound(soundError);
                 return;
            }

            if (!heldDice[index] && heldDice[otherIndex]) {
                 showTemporaryMessage("Je kunt maar één dobbelsteen vasthouden.");
                 playSound(soundError);
                 return;
            }

            heldDice[index] = !heldDice[index];
            dieElement.classList.toggle('held', heldDice[index]); // Only toggle visual held class

             if (heldDice[index]) {
                 playSound(soundHoldDie);
                console.log(`Held die ${index}.`);
            } else {
                console.log(`Released die ${index}.`);
            }
        }


        // --- Turn & Round Ending Logic ---
        function endPlayerTurn() {
            gameState = 'turnOver';
            mainActionBtn.textContent = 'Volgende Speler'; // Set button text
            mainActionBtn.disabled = false; // Ensure button is clickable to advance
            showLowestBtn.disabled = true;
            allowHolding = false;
            die1Div.classList.remove('shaking', 'held', 'clickable'); // Clean UI
            die2Div.classList.remove('shaking', 'held', 'clickable');
            heldDice = [false, false];
            lockedDieIndex = null;

            const actualPlayerIndex = roundTurnOrder[currentPlayerIndex];
            const finalScoreValue = playerRoundData[actualPlayerIndex].finalThrowValue;
            const currentPlayerName = playerRoundData[actualPlayerIndex].name;
            const currentScoreDisplay = playerRoundData[actualPlayerIndex].scoreDisplay;

            // --- Lowest Score & Overtake Logic ---
            if (finalScoreValue !== null && finalScoreValue !== 31 && finalScoreValue !== 32) {
                 const scoreToCompare = finalScoreValue;
                 const canMexBeLowest = onlyMexRolledSoFar && scoreToCompare === 1000;

                 if (scoreToCompare < roundLowestScore || (canMexBeLowest && roundLowestScore === Infinity)) {
                     roundLowestScore = scoreToCompare;
                     roundLowestPlayerIndices = [actualPlayerIndex];
                     console.log(`New lowest score: ${currentScoreDisplay} by ${currentPlayerName}`);
                 }
                 else if (scoreToCompare === roundLowestScore) {
                     if (!roundLowestPlayerIndices.includes(actualPlayerIndex)) {
                         const previousLowestPlayerIndex = roundLowestPlayerIndices[0];

                         const drinksForThisOvertake = 1 * Math.pow(2, mexCountThisRound);
                         const currentOvertakeDrinks = overtakenPlayersMap.get(previousLowestPlayerIndex) || 0;
                         overtakenPlayersMap.set(previousLowestPlayerIndex, currentOvertakeDrinks + drinksForThisOvertake);
                         console.log(`Player ${previousLowestPlayerIndex} overtaken, owes ${overtakenPlayersMap.get(previousLowestPlayerIndex)} drinks`);

                         roundLowestPlayerIndices = [actualPlayerIndex]; // Current player takes over

                         showTemporaryMessage(`${currentPlayerName} neemt laag over!  ${playerRoundData[previousLowestPlayerIndex]?.name || 'Iemand'} moet ${1 * Math.pow(2, mexCountThisRound)} drinken!`, 'special');
                         console.log(`${currentPlayerName} overtakes/ties lowest score ${currentScoreDisplay} from ${playerRoundData[previousLowestPlayerIndex]?.name || 'Previous'}`);
                     }
                 }
            }

            // --- End Turn Message ---
            if (!messageAreaDiv.classList.contains('visible')) {
                 const displayScore = currentScoreDisplay || "Geen score";
                 // Keep message simple, button handles advance
                showTemporaryMessage(`Beurt van ${currentPlayerName} is klaar.`);
            }
             // State is set at the top of the function now
        }


        function advanceToNext() {
             // Called by the main action button when in 'turnOver' state
             hideMessage(); // Hide the "turn over" message
            currentPlayerIndex++;
            if (currentPlayerIndex < roundTurnOrder.length) {
                setupPlayerTurn();
            } else {
                endRound();
            }
        }

        function endRound() {
            gameState = 'roundOver';
            mainActionBtn.disabled = true; // Disable the main button
            mainActionBtn.textContent = "Ronde Klaar"; // Update text
            showLowestBtn.disabled = true;
            hideMessage();
            playSound(soundRoundEnd);

            // --- Hide Game Elements ---
            diceContainer.style.display = 'none';
            spelInfoDiv.style.display = 'none';
            scoreDisplayDiv.style.display = 'none';
            actieKnoppenDiv.style.display = 'none'; // Hide the button container

            let drinksMultiplier = Math.pow(2, mexCountThisRound);
            let actionMessages = [];
            let scoreHTML = "<strong>Worp details</strong><br>";
            let actualRoundLowestNormalScoreValue = Infinity;
            let lowestScoreDisplayValue = null;
            let drinksForLowest = 0; // Initialize drinks for lowest score penalty
            let lowestPlayersForPenalty = []; // Initialize list of players taking penalty
            let lowestPlayerIndicesForPenalty = []; // Initialize list of player indices taking penalty

             // --- Calculate Drinks & Actions ---
            // 1. Process 31/32 drinks
            playerRoundData.forEach((data) => {
                 if (data.drinksGivenFrom31 > 0) actionMessages.push(`<strong>${data.name}</strong> deelt ${data.drinksGivenFrom31} ${pluralizeSlok(data.drinksGivenFrom31)} uit (31).`);
                 if (data.drinksTakenFrom32 > 0) actionMessages.push(`<strong>${data.name}</strong> drinkt ${data.drinksTakenFrom32} ${pluralizeSlok(data.drinksTakenFrom32)} (32).`);
             });

            // 2. Process Accumulated Overtake Drinks
            if (overtakenPlayersMap.size > 0) {
                overtakenPlayersMap.forEach((totalOvertakeDrinks, playerIndex) => {
                    if (playerRoundData[playerIndex]) {
                        const overtakenPlayerName = playerRoundData[playerIndex].name;
                        const overtakenScoreApprox = playerRoundData[playerIndex].scoreDisplay || '?';
                        actionMessages.push(`<strong>${overtakenPlayerName}</strong> drinkt ${totalOvertakeDrinks} ${pluralizeSlok(totalOvertakeDrinks)} (${overtakenScoreApprox} laag overgenomen).`);
                        playerRoundData[playerIndex].drinksToTake += totalOvertakeDrinks;
                    } else {
                         console.error("Overtaken player index out of bounds:", playerIndex);
                    }
                });
            }

            // 3. Process Lowest Score Penalty
            if (roundLowestPlayerIndices.length > 0 && roundLowestScore !== Infinity) {
                 drinksForLowest = 1 * drinksMultiplier; // Calculate penalty drinks here
                 //lowestPlayersForPenalty = []; // Already initialized above
                 //lowestPlayerIndicesForPenalty = []; // Already initialized above

                 let displayScoreForMsg = "";
                  if (roundLowestScore === 1000) {
                      displayScoreForMsg = "Mex";
                  } else {
                       for(let i = 0; i < playerRoundData.length; i++) {
                           const pData = playerRoundData[i];
                           const finalThrow = pData.throwsHistory.slice().reverse().find(t => t.scoreResult.type !== 'special');
                           if(finalThrow && finalThrow.scoreResult.type === 'normal' && finalThrow.scoreResult.value === roundLowestScore) {
                               lowestScoreDisplayValue = finalThrow.scoreResult.display;
                               displayScoreForMsg = lowestScoreDisplayValue;
                               break;
                           }
                       }
                       if (!displayScoreForMsg) displayScoreForMsg = roundLowestScore.toString();
                   }


                 roundLowestPlayerIndices.forEach(index => {
                     if (!overtakenPlayersMap.has(index)) { // Only apply penalty if not already penalized for being overtaken
                         if (playerRoundData[index]) {
                             playerRoundData[index].drinksToTake += drinksForLowest;
                             lowestPlayersForPenalty.push(`<strong>${playerRoundData[index].name}</strong>`);
                             lowestPlayerIndicesForPenalty.push(index);
                         }
                     }
                 });

                 if (lowestPlayersForPenalty.length > 0) {
                     if (lowestPlayersForPenalty.length === 1) {
                         actionMessages.push(`${lowestPlayersForPenalty[0]} laagste score (${displayScoreForMsg}), ${drinksForLowest} ${pluralizeSlok(drinksForLowest)}.`);
                     } else {
                         actionMessages.push(`Gelijkspel laagste score (${displayScoreForMsg}): ${lowestPlayersForPenalty.join(', ')} drinken elk ${drinksForLowest} ${pluralizeSlok(drinksForLowest)}.`);
                     }
                 }
            }
            else if (roundLowestScore === Infinity && overtakenPlayersMap.size === 0) {
                 actionMessages.push("Geen geldige laagste score bepaald deze ronde.");
            }


            // --- Build Action Display HTML ---
             let actionsHTML = "<strong class='actions-section'>Drinken!</strong><br>";
             actionsHTML += '<div class="actions-section">';
             actionsHTML += actionMessages.length > 0 ? actionMessages.join('<br>') : "Geen speciale acties deze ronde.";
             if (mexCountThisRound > 0) {
                  const mexWord = numberToWord(mexCountThisRound);
                 actionsHTML += `<br><em>(${pluralizeSlok(2)} x${drinksMultiplier} door ${mexWord} Mex worp${mexCountThisRound > 1 ? 'en' : ''})</em>`;
             }
             actionsHTML += '</div>';
            resultatenActiesDiv.innerHTML = actionsHTML; // RENDER ACTIONS FIRST


            // --- Build and Render Score History HTML (in Turn Order) ---
            for (let i = 0; i < roundTurnOrder.length; i++) {
                 const actualPlayerIndex = roundTurnOrder[i];
                 const data = playerRoundData[actualPlayerIndex];

                 scoreHTML += `<div class="score-section">`;
                 scoreHTML += `<strong class="player-name">${data.name}:</strong>`;
                 scoreHTML += `<span class="throw-history" data-player-index="${data.id}">`; // Use original ID

                 let finalThrowIndex = -1;
                 if (data.throwsHistory.length > 0) {
                     for(let j = data.throwsHistory.length - 1; j >= 0; j--) {
                         if(data.throwsHistory[j].scoreResult.type !== 'special') {
                             finalThrowIndex = j;
                             break;
                         }
                     }

                     data.throwsHistory.forEach((throwData, index) => {
                         const scoreStr = throwData.scoreResult.display;
                         let classes = [];
                         if (index === finalThrowIndex) classes.push('final-throw');
                         if (throwData.scoreResult.type === 'special') classes.push('special-throw');
                         scoreHTML += `<span class="${classes.join(' ')}" data-score-value="${throwData.scoreResult.value}" data-score-type="${throwData.scoreResult.type}">${scoreStr}</span>`;
                     });
                 } else {
                     scoreHTML += ` (Geen geldige worpen)`;
                 }
                 scoreHTML += `</span></div>`;
             }
            resultatenScoresDiv.innerHTML = scoreHTML; // RENDER HISTORY SECOND


             // --- Highlight Lowest Scores in Rendered History ---
             if (lowestScoreDisplayValue !== null && roundLowestScore !== 1000) {
                  // Use lowestPlayerIndicesForPenalty to ensure only those who actually drink are highlighted
                  lowestPlayerIndicesForPenalty.forEach(playerIndex => {
                      const playerHistorySpan = resultatenScoresDiv.querySelector(`.throw-history[data-player-index="${playerIndex}"]`);
                      if (playerHistorySpan) {
                          const finalThrowSpan = playerHistorySpan.querySelector('.final-throw');
                          // Double-check if the final throw actually matches the lowest display value
                          if (finalThrowSpan && finalThrowSpan.textContent === lowestScoreDisplayValue && finalThrowSpan.dataset.scoreType === 'normal') {
                              finalThrowSpan.classList.add('lowest-score-highlight');
                          } else {
                              // Fallback or alternative highlighting if needed, e.g., if the final throw was special
                              console.log(`Could not highlight final throw for ${playerRoundData[playerIndex]?.name} with score ${lowestScoreDisplayValue}`)
                          }
                      }
                  });
             }


            // --- START: Add logic for lowest score announcement ---
            const announcementDiv = document.getElementById('lowest-score-announcement');
            let announcementMsg = "";

            // Use the already calculated lowest player penalty info
            if (lowestPlayersForPenalty.length > 0 && drinksForLowest > 0) {
                // Get clean names (remove the <strong> tags used elsewhere)
                const loserNames = lowestPlayersForPenalty.map(p => p.replace(/<\/?strong>/g, '')).join(' en ');
                const slokText = pluralizeSlok(drinksForLowest);
                announcementMsg = `${loserNames} laag! ${drinksForLowest} ${slokText} drinken!`;
            } else {
                 // Optionally display a message if no one has the lowest penalty (e.g., only overtakes)
                 // announcementMsg = "Geen directe laagste score straf.";
            }

            if (announcementDiv) {
                announcementDiv.textContent = announcementMsg; // Use textContent for safety
            }

            // Add a class to the parent to control visibility via CSS
            rondeResultatenDiv.classList.add('showing-results');
            // --- END: Add logic for lowest score announcement ---


            // --- Prepare for Next Round ---
            lastRoundLowestIndices = roundLowestPlayerIndices.length > 0 ? [...lowestPlayerIndicesForPenalty] : []; // Use the indices of those actually penalized


            // Show results container and enable next round button (existing lines)
            rondeResultatenDiv.style.display = 'block';
            nextRoundBtn.disabled = false;
        } // End of endRound function


        // --- Utility Functions ---
        function showLowestScoreInfo() {
             playSound(soundShowLowest); // Play specific sound
             if (roundLowestScore === Infinity) {
                showTemporaryMessage("Nog geen laagste score bepaald in deze ronde.");
            } else {
                 let lowestScoreDisplay;
                 if (roundLowestScore === 1000) {
                     lowestScoreDisplay = "Mex";
                 } else if (roundLowestPlayerIndices.length > 0 && playerRoundData[roundLowestPlayerIndices[0]]) {
                     const firstLowestPlayer = playerRoundData[roundLowestPlayerIndices[0]];
                     const lastValidThrow = firstLowestPlayer.throwsHistory.slice().reverse().find(t => t.scoreResult.type !== 'special');
                      if(lastValidThrow && lastValidThrow.scoreResult.value === roundLowestScore){
                          lowestScoreDisplay = lastValidThrow.scoreResult.display;
                      } else {
                           // Attempt to find display value from *any* player with that score
                           let foundDisplay = null;
                           for (let idx of roundLowestPlayerIndices) {
                               const pData = playerRoundData[idx];
                               const throwWithScore = pData?.throwsHistory.slice().reverse().find(t => t.scoreResult.value === roundLowestScore && t.scoreResult.type === 'normal');
                               if (throwWithScore) {
                                   foundDisplay = throwWithScore.scoreResult.display;
                                   break;
                               }
                           }
                           lowestScoreDisplay = foundDisplay || roundLowestScore.toString();
                      }
                 } else {
                      lowestScoreDisplay = roundLowestScore.toString();
                 }

                 const lowestPlayerNames = roundLowestPlayerIndices.map(i => playerRoundData[i]?.name || 'Onbekend').join(', ');
                showTemporaryMessage(`Huidige laagste score: ${lowestScoreDisplay} (van ${lowestPlayerNames})`);
            }
        }

        function showTemporaryMessage(msg, type = 'info') {
            messageAreaDiv.innerHTML = msg;
            messageAreaDiv.className = 'message-area visible';
            if (type === 'special') {
                messageAreaDiv.classList.add('special');
            }
        }

        function hideMessage() {
            messageAreaDiv.className = 'message-area';
        }

        // --- Initialisation ---
        checkStartGameButton();
        hideMessage();
    
    </script>
<script defer src="src/dice.js"></script>
<script defer src="src/main.js"></script>
<script defer src="src/ui.js"></script>
</body>
</html>