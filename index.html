<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Penguin Mex</title>
    <style>
        /* --- Enhanced Visual Styling --- */
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');

        :root {
            --primary-color: #34495e; /* Dark Slate Blue */
            --secondary-color: #3498db; /* Bright Blue */
            --accent-color: #e74c3c; /* Red */
            --background-start: #f8f9fa; /* Very Light Gray */
            --background-end: #e9ecef;   /* Light Gray */
            --text-color: #2c3e50; /* Darker Slate Blue */
            --light-text: #ffffff;
            --border-color: #ced4da; /* Medium Gray */
            --dice-bg: #fdfdfd; /* Almost White */
            --dice-dot: #2c3e50; /* Dark Slate Blue */
            --special-message-bg: #fff3cd; /* Light Yellow */
            --special-message-border: #ffeeba;
            --special-message-text: #856404;
            --shadow-color: rgba(0, 0, 0, 0.15);
            --shadow-color-light: rgba(0, 0, 0, 0.08);
            /* Dice Size */
            --dice-size: 95px;
            --dot-size: 18px;
            --dice-padding: 9px;
            --dice-gap: 5px;
            --dice-radius: 18px;
        }

        html {
             height: 100%;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-image: linear-gradient(to bottom, var(--background-start), var(--background-end));
            color: var(--text-color);
            margin: 0;
            padding: 15px 15px 25px 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100%;
            overflow-x: hidden;
            overflow-y: auto;
            box-sizing: border-box;
        }

        .title-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-shrink: 0;
        }

        .penguin-logo {
            height: 40px;
            width: auto;
        }

        h1 {
            color: var(--primary-color);
            text-align: center;
            margin: 0;
            font-weight: 600;
            font-size: 2.0em;
            text-shadow: 1px 1px 2px var(--shadow-color-light);
        }

        h2, h3 {
            color: var(--primary-color);
            text-align: center;
            margin-top: 0;
            margin-bottom: 15px;
            font-weight: 600;
        }

        h2 { font-size: 1.6em; }
        h3 { font-size: 1.3em; }

        .container {
            background-color: var(--light-text);
            padding: 25px;
            border-radius: 16px;
            box-shadow: 0 8px 25px var(--shadow-color);
            border: 1px solid rgba(0,0,0,0.05);
            width: 95%;
            max-width: 480px;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 18px;
            flex-shrink: 0;
        }

        #setup-fase { display: flex; flex-direction: column; align-items: center; }
        #player-input {
            padding: 12px 18px; border: 1px solid var(--border-color);
            border-radius: 8px; width: 80%; font-size: 1em;
            margin-bottom: 10px; transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        #player-input:focus {
            border-color: var(--secondary-color);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
            outline: none;
        }
        #player-list {
            list-style: none; padding: 0; margin-top: 10px;
            width: 100%; text-align: center;
        }
        #player-list li {
            background-color: var(--background-start);
            padding: 9px 14px; margin-bottom: 7px;
            border-radius: 6px; font-weight: 600; color: var(--primary-color);
            border: 1px solid var(--border-color);
            transition: transform 0.2s ease;
        }
         #player-list li:hover {
             transform: scale(1.02);
         }

        #spel-fase { display: none; flex-direction: column; align-items: center; }
        #spel-info {
            width: 100%; display: flex; justify-content: space-between;
            align-items: center; margin-bottom: 10px; padding: 0 5px;
            flex-wrap: wrap; gap: 8px;
        }
        #speler-aan-zet {
             font-size: 1.3em; font-weight: 700; margin: 0;
             color: var(--secondary-color);
             text-shadow: 1px 1px 1px var(--shadow-color-light);
        }
        #worp-info { font-size: 1.0em; font-weight: 600; margin: 0; color: var(--primary-color); }

        /* --- Bigger & Prettier Dice Styling --- */
        .dice-container {
            display: flex; justify-content: center; gap: 35px;
            margin-bottom: 25px;
            perspective: 1200px;
            min-height: calc(var(--dice-size) + 10px);
        }

        .die {
            width: var(--dice-size); height: var(--dice-size);
            background: linear-gradient(145deg, #ffffff, #e8e8e8);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--dice-radius);
            padding: var(--dice-padding);
            display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr);
            gap: var(--dice-gap);
            box-shadow: 6px 6px 18px rgba(0,0,0,0.12),
                       -6px -6px 18px rgba(255,255,255,0.8),
                       inset 0 3px 5px rgba(255, 255, 255, 0.7),
                       inset 0 -3px 5px rgba(0, 0, 0, 0.06);
            cursor: default;
            transition: border-color 0.3s ease, box-shadow 0.3s ease, transform 0.5s ease-out;
            transform-style: preserve-3d;
        }
        .die.clickable { cursor: pointer; }
        .die.clickable:hover {
            transform: scale(1.05) rotateY(6deg);
            box-shadow: 8px 8px 22px rgba(0,0,0,0.18),
                       -6px -6px 18px rgba(255,255,255,0.8),
                       inset 0 3px 5px rgba(255, 255, 255, 0.7),
                       inset 0 -3px 5px rgba(0, 0, 0, 0.06);
        }
        .die.held {
            border-color: var(--accent-color);
            box-shadow: 0 0 18px var(--accent-color),
                       6px 6px 18px rgba(0,0,0,0.12),
                       -6px -6px 18px rgba(255,255,255,0.8),
                       inset 0 3px 5px rgba(255, 255, 255, 0.7),
                       inset 0 -3px 5px rgba(0, 0, 0, 0.06);
            transform: scale(1.02);
        }
        .die.cannot-hold {
            /* opacity: 0.8; */
        }

        .dot {
            width: var(--dot-size); height: var(--dot-size);
            background-color: var(--dice-dot);
            border-radius: 50%;
            align-self: center; justify-self: center;
            box-shadow: inset 1.5px 1.5px 4px rgba(0, 0, 0, 0.65),
                       0 0 2px rgba(0, 0, 0, 0.25);
            visibility: hidden;
        }
        /* Dot positioning remains the same */
        .dot:nth-child(1) { grid-area: 1 / 1; } .dot:nth-child(2) { grid-area: 1 / 2; } .dot:nth-child(3) { grid-area: 1 / 3; }
        .dot:nth-child(4) { grid-area: 2 / 1; } .dot:nth-child(5) { grid-area: 2 / 2; } .dot:nth-child(6) { grid-area: 2 / 3; }
        .dot:nth-child(7) { grid-area: 3 / 1; } .dot:nth-child(8) { grid-area: 3 / 2; } .dot:nth-child(9) { grid-area: 3 / 3; }
        /* Dot visibility rules remain the same */
        .die[data-value="0"] .dot { visibility: hidden; }
        .die[data-value="1"] .dot:nth-child(5) { visibility: visible; }
        .die[data-value="2"] .dot:nth-child(1), .die[data-value="2"] .dot:nth-child(9) { visibility: visible; }
        .die[data-value="3"] .dot:nth-child(1), .die[data-value="3"] .dot:nth-child(5), .die[data-value="3"] .dot:nth-child(9) { visibility: visible; }
        .die[data-value="4"] .dot:nth-child(1), .die[data-value="4"] .dot:nth-child(3), .die[data-value="4"] .dot:nth-child(7), .die[data-value="4"] .dot:nth-child(9) { visibility: visible; }
        .die[data-value="5"] .dot:nth-child(1), .die[data-value="5"] .dot:nth-child(3), .die[data-value="5"] .dot:nth-child(5), .die[data-value="5"] .dot:nth-child(7), .die[data-value="5"] .dot:nth-child(9) { visibility: visible; }
        .die[data-value="6"] .dot:nth-child(1), .die[data-value="6"] .dot:nth-child(3), .die[data-value="6"] .dot:nth-child(4), .die[data-value="6"] .dot:nth-child(6), .die[data-value="6"] .dot:nth-child(7), .die[data-value="6"] .dot:nth-child(9) { visibility: visible; }

        .score-display {
            font-size: 1.8em; font-weight: 700; color: var(--secondary-color);
            text-align: center; margin-top: 0px; margin-bottom: 15px;
            text-shadow: 1px 1px 1px var(--shadow-color-light);
        }

        .message-area {
            min-height: 25px; padding: 10px 15px;
            background-color: var(--special-message-bg);
            border: 1px solid var(--special-message-border);
            border-radius: 8px; text-align: center;
            font-weight: 600; color: var(--special-message-text);
            margin-top: 8px; margin-bottom: 12px; display: none;
            transition: opacity 0.3s ease;
            box-shadow: 0 2px 4px var(--shadow-color-light);
        }
        .message-area.visible { display: block; opacity: 1; }
        .message-area.special {
            color: var(--accent-color); font-size: 1.05em;
            background-color: #f8d7da; border-color: #f5c6cb;
        }

        /* --- Button Styling --- */
        button {
            background-image: linear-gradient(to bottom, var(--secondary-color), #2980b9);
            color: white; border: none; padding: 12px 24px;
            border-radius: 10px; cursor: pointer; font-size: 1.0em;
            font-weight: 600; font-family: 'Poppins', sans-serif;
            transition: background-image 0.3s ease, transform 0.15s ease, box-shadow 0.3s ease;
            box-shadow: 0 3px 8px rgba(52, 152, 219, 0.4);
            text-transform: uppercase; letter-spacing: 0.5px;
        }
        button:hover:not(:disabled) {
            background-image: linear-gradient(to bottom, #3ba0e0, #2f89c0);
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(52, 152, 219, 0.5);
        }
        button:active:not(:disabled) {
            transform: translateY(0px);
            box-shadow: 0 2px 6px rgba(52, 152, 219, 0.3);
        }
        button:disabled {
            background-image: linear-gradient(to bottom, #bdc3c7, #a5acb1);
            cursor: not-allowed; opacity: 0.7;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transform: translateY(0);
        }

        #actie-knoppen { display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; width: 100%; }

        /* --- Results Styling --- */
         #ronde-resultaten {
            display: none; margin-top: 20px; padding: 20px 25px;
            background-image: linear-gradient(to bottom, var(--primary-color), #2c3e50);
            border-radius: 12px; text-align: left; color: var(--light-text);
            width: 95%; max-width: 480px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
         }
         #ronde-resultaten h3 {
             margin-top: 0; color: var(--light-text); text-align: center;
             margin-bottom: 15px; font-size: 1.4em;
             text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        /* Scores section */
        #ronde-resultaten .score-section {
            margin-bottom: 10px;
            color: #ecf0f1;
            font-size: 1.0em;
            line-height: 1.6;
        }
         #ronde-resultaten .score-section strong.player-name {
             color: #aed6f1;
             font-size: 1.1em;
             display: block;
             margin-bottom: 3px;
         }
        #ronde-resultaten .score-section .throw-history {
            font-size: 0.95em;
            color: #bdc3c7;
            padding-left: 10px;
            display: block;
        }
        #ronde-resultaten .score-section .throw-history span {
            margin-right: 10px;
            display: inline-block;
        }
         #ronde-resultaten .score-section .throw-history .final-throw {
            font-weight: 700;
            color: #ffffff;
         }
        #ronde-resultaten .score-section .throw-history .lowest-score-highlight {
            color: var(--accent-color); /* Red */
            font-weight: bold;
         }
         #ronde-resultaten .score-section .throw-history .special-throw {
            font-style: italic;
            opacity: 0.8;
         }

         /* Actions section */
         #ronde-resultaten .actions-section {
            margin-top: 15px;
            color: #ecf0f1;
            font-size: 1.0em;
            line-height: 1.5;
         }
         #ronde-resultaten .actions-section strong {
             color: #aed6f1;
         }

         #ronde-resultaten hr { border: none; border-top: 1px solid rgba(255, 255, 255, 0.2); margin: 15px 0; }
         #ronde-resultaten button {
             margin-top: 15px;
             background-image: linear-gradient(to bottom, var(--secondary-color), #2980b9);
             box-shadow: 0 3px 8px rgba(52, 152, 219, 0.4);
             display: block;
             margin-left: auto;
             margin-right: auto;
        }
        #ronde-resultaten em {
            display: block;
            text-align: center;
            margin-top: 10px;
            font-size: 0.9em;
            color: #bdc3c7;
        }

        /* --- Shake Animation --- */
        @keyframes shake {
            0% { transform: translate(0, 0) rotateX(0) rotateY(0); }
            10% { transform: translate(-5px, -3px) rotateX(-6deg) rotateY(5deg); }
            20% { transform: translate(5px, 3px) rotateX(5deg) rotateY(-6deg); }
            30% { transform: translate(-4px, -2px) rotateX(-4deg) rotateY(3deg); }
            40% { transform: translate(4px, 2px) rotateX(3deg) rotateY(-4deg); }
            50% { transform: translate(-3px, -1px) rotateX(-2deg) rotateY(2deg); }
            60% { transform: translate(3px, 1px) rotateX(2deg) rotateY(-2deg); }
            70% { transform: translate(-2px, 0px) rotateX(-1deg) rotateY(1deg); }
            80% { transform: translate(2px, 0px) rotateX(1deg) rotateY(-1deg); }
            90% { transform: translate(-1px, 0px) rotateX(0deg) rotateY(0deg); }
            100% { transform: translate(0, 0) rotateX(0) rotateY(0); }
        }
        .die.shaking {
            animation: shake 0.65s cubic-bezier(.36,.07,.19,.97) both;
            transform: translateZ(12px);
        }

        /* --- Responsiveness --- */
        @media (max-width: 500px) {
             :root {
                --dice-size: 75px;
                --dot-size: 14px;
                --dice-padding: 7px;
                --dice-gap: 4px;
                --dice-radius: 14px;
            }
             .container { padding: 20px; gap: 15px; max-width: 95%;}
             .title-container { gap: 8px; margin-bottom: 10px;}
             h1 { font-size: 1.8em; }
             .penguin-logo { height: 35px; }
             .dice-container { gap: 25px; }
             #spel-info { flex-direction: column; align-items: center; gap: 5px; }
             #speler-aan-zet { font-size: 1.2em; }
             .score-display { font-size: 1.6em; }
             #actie-knoppen { flex-direction: column; width: 95%; align-items: stretch;}
             button { width: 100%; padding: 11px 18px; font-size: 0.95em;}
             #ronde-resultaten { padding: 15px 20px; }
             #ronde-resultaten h3 { font-size: 1.3em; }
             #ronde-resultaten .score-section,
             #ronde-resultaten .actions-section { font-size: 0.95em; }
              #ronde-resultaten .score-section .throw-history { font-size: 0.9em; }
        }
         @media (max-width: 380px) {
             :root {
                --dice-size: 65px;
                --dot-size: 12px;
                --dice-padding: 6px;
                --dice-gap: 3px;
                --dice-radius: 12px;
            }
             .dice-container { gap: 15px; }
             button { padding: 10px 15px; }
         }
    </style>
</head>
<body>
    <div class="title-container">
        <svg class="penguin-logo" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
          <path fill="#2c3e50" d="M50 10 C 30 10, 15 30, 15 50 C 15 80, 35 95, 50 95 C 65 95, 85 80, 85 50 C 85 30, 70 10, 50 10 Z"/>
          <path fill="#ffffff" d="M50 25 C 40 25, 30 40, 30 55 C 30 75, 40 85, 50 85 C 60 85, 70 75, 70 55 C 70 40, 60 25, 50 25 Z"/>
          <ellipse fill="#e67e22" cx="50" cy="75" rx="15" ry="5"/>
          <ellipse fill="#2c3e50" cx="42" cy="45" rx="4" ry="6"/>
          <ellipse fill="#2c3e50" cx="58" cy="45" rx="4" ry="6"/>
          <path fill="#e67e22" d="M 48 60 Q 50 65 52 60 Q 50 58 48 60 Z"/>
          <path fill="#2c3e50" d="M 15 50 C 10 55, 5 70, 10 80 C 20 75, 25 60, 15 50 Z" />
          <path fill="#2c3e50" d="M 85 50 C 90 55, 95 70, 90 80 C 80 75, 75 60, 85 50 Z" />
        </svg>
        <h1>Penguin Mex</h1>
    </div>

    <!-- Setup Fase -->
    <div id="setup-fase" class="container">
        <h2>Spelers</h2>
        <input type="text" id="player-input" placeholder="Naam speler">
        <button id="add-player-btn">Voeg Toe</button>
        <ul id="player-list"></ul>
        <button id="start-game-btn" disabled>Start Spel</button>
        <p><small>Minimaal 2 spelers nodig.</small></p>
    </div>

    <!-- Spel Fase -->
    <div id="spel-fase" class="container">
        <h2 id="ronde-titel">Ronde 1</h2>
        <div id="spel-info">
             <h3 id="speler-aan-zet">Speler: ...</h3>
             <div id="worp-info">Worp: <span id="worp-teller">0</span> / <span id="max-worpen">3</span></div>
        </div>

        <div class="dice-container">
             <div id="die1" class="die" data-value="0">
                <span class="dot"></span><span class="dot"></span><span class="dot"></span>
                <span class="dot"></span><span class="dot"></span><span class="dot"></span>
                <span class="dot"></span><span class="dot"></span><span class="dot"></span>
            </div>
            <div id="die2" class="die" data-value="0">
                <span class="dot"></span><span class="dot"></span><span class="dot"></span>
                <span class="dot"></span><span class="dot"></span><span class="dot"></span>
                <span class="dot"></span><span class="dot"></span><span class="dot"></span>
            </div>
        </div>

        <div id="score-display" class="score-display">Score: -</div>
        <div id="message-area" class="message-area"></div>

        <div id="actie-knoppen">
            <button id="roll-btn" disabled>Gooi</button>
            <button id="show-lowest-btn">Toon Laagste</button>
        </div>

        <div id="ronde-resultaten">
             <h3>Ronde Resultaten</h3>
             <!-- DIV for scores -->
             <div id="resultaten-scores"></div>
             <hr>
             <!-- DIV for actions -->
             <div id="resultaten-acties"></div>
             <button id="next-round-btn">Volgende Ronde</button>
         </div>
    </div>

    <script>
        // --- JavaScript ---

        // Globale Variabelen
        let players = [];
        let playerRoundData = []; /* { name, id, scoreDisplay, drinksToTake, finalThrowValue,
                                     throwsHistory: [{scoreResult}], drinksGivenFrom31, drinksTakenFrom32 } */
        let currentRound = 0;
        let gameState = 'setup';
        let roundThrowsLimit = 3;
        let mexCountThisRound = 0;
        let roundLowestScore = Infinity;
        let roundLowestPlayerIndices = []; // Stores original player indices
        let onlyMexRolledSoFar = true;
        let roundTurnOrder = [];
        let currentPlayerIndex = 0; // Index into roundTurnOrder
        let lastRoundLowestIndices = [];
        // NEW: Map to track accumulated overtake penalties
        let overtakenPlayersMap = new Map(); // Stores <playerIndex, totalOvertakeDrinks>
        // Current Turn State
        let throwsThisTurn = 0;
        let currentDice = [0, 0];
        let currentScoreResult = {};
        let heldDice = [false, false];
        let mustThrowHeld = false;
        let allowHolding = false;
        // No longer need single overtakenPlayerIndex globally
        // let overtakenPlayerIndex = null;
        let animationInterval = null;

        // DOM Elementen (remains the same)
        const setupFaseDiv = document.getElementById('setup-fase');
        const spelFaseDiv = document.getElementById('spel-fase');
        const playerInput = document.getElementById('player-input');
        const addPlayerBtn = document.getElementById('add-player-btn');
        const playerListUl = document.getElementById('player-list');
        const startGameBtn = document.getElementById('start-game-btn');
        const rondeTitel = document.getElementById('ronde-titel');
        const spelerAanZetH3 = document.getElementById('speler-aan-zet');
        const die1Div = document.getElementById('die1');
        const die2Div = document.getElementById('die2');
        const scoreDisplayDiv = document.getElementById('score-display');
        const worpTellerSpan = document.getElementById('worp-teller');
        const maxWorpenSpan = document.getElementById('max-worpen');
        const messageAreaDiv = document.getElementById('message-area');
        const rollBtn = document.getElementById('roll-btn');
        const nextRoundBtn = document.getElementById('next-round-btn');
        const showLowestBtn = document.getElementById('show-lowest-btn');
        const rondeResultatenDiv = document.getElementById('ronde-resultaten');
        const resultatenScoresDiv = document.getElementById('resultaten-scores');
        const resultatenActiesDiv = document.getElementById('resultaten-acties');

        // --- Helper Functions ---
        function pluralizeSlok(count) {
            return count === 1 ? "slok" : "slokken";
        }

        function numberToWord(num) {
            const words = ["nul", "één", "twee", "drie", "vier", "vijf", "zes"];
            return words[num] || num.toString();
        }

        // --- Event Listeners ---
        addPlayerBtn.addEventListener('click', addPlayer);
        playerInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addPlayer(); });
        startGameBtn.addEventListener('click', startGame);
        rollBtn.addEventListener('click', handleMainButtonClick);
        nextRoundBtn.addEventListener('click', startNewRound);
        showLowestBtn.addEventListener('click', showLowestScoreInfo);
        die1Div.addEventListener('click', () => handleDieClick(0));
        die2Div.addEventListener('click', () => handleDieClick(1));

        // --- Main Button Logic ---
        function handleMainButtonClick() {
            if (gameState === 'playing') {
                startRollAnimation();
            } else if (gameState === 'turnOver') {
                advanceToNext();
            }
        }

        // --- Player Setup Functions ---
        function addPlayer() {
            const playerName = playerInput.value.trim();
            if (playerName && players.length < 10) {
                players.push({ name: playerName });
                playerInput.value = '';
                updatePlayerList();
                checkStartGameButton();
            } else if (players.length >= 10) {
                 showTemporaryMessage("Max 10 spelers toegestaan.", 'special');
            }
            playerInput.focus();
        }

        function updatePlayerList() {
             playerListUl.innerHTML = '';
            players.forEach(player => {
                const li = document.createElement('li');
                li.textContent = player.name;
                playerListUl.appendChild(li);
            });
        }

        function checkStartGameButton() {
            startGameBtn.disabled = players.length < 2;
        }

        // --- Game Flow Functions ---
        function startGame() {
            if (players.length < 2) return;
            lastRoundLowestIndices = [];
            setupFaseDiv.style.display = 'none';
            spelFaseDiv.style.display = 'flex';
            hideMessage();
            startNewRound();
        }

        function startNewRound() {
            rondeResultatenDiv.style.display = 'none';
            nextRoundBtn.disabled = true;
            hideMessage();

            currentRound++;
            rondeTitel.textContent = `Ronde ${currentRound}`;
            roundThrowsLimit = 3;
            mexCountThisRound = 0;
            roundLowestScore = Infinity;
            roundLowestPlayerIndices = [];
            onlyMexRolledSoFar = true;
            overtakenPlayersMap = new Map(); // Reset overtake map for the new round

            // Determine Turn Order
            roundTurnOrder = [];
            if (lastRoundLowestIndices.length > 0) {
                const startingPlayerIndex = lastRoundLowestIndices[0];
                roundTurnOrder.push(startingPlayerIndex);
                let currentIndex = (startingPlayerIndex + 1) % players.length;
                while (roundTurnOrder.length < players.length) { // Ensure all players are added
                     if (!lastRoundLowestIndices.includes(currentIndex)) {
                         roundTurnOrder.push(currentIndex);
                     }
                     currentIndex = (currentIndex + 1) % players.length;
                     // Safety break (shouldn't be needed with modulo)
                     if (currentIndex === startingPlayerIndex && roundTurnOrder.length < players.length) {
                          console.error("Turn order calculation error!");
                          // Fallback to default order if something goes wrong
                          roundTurnOrder = players.map((_, index) => index);
                          break;
                     }
                 }
                 // Add any other tied lowest players if not already added
                  lastRoundLowestIndices.slice(1).forEach(idx => {
                      if (!roundTurnOrder.includes(idx)) {
                           roundTurnOrder.push(idx);
                      }
                  });

            } else {
                // First round: normal order
                roundTurnOrder = players.map((_, index) => index);
            }
            console.log("New Round Turn Order (indices):", roundTurnOrder);

            // Reset round data
            playerRoundData = players.map((p, index) => ({
                name: p.name,
                id: index, // Store original index
                scoreDisplay: null,
                drinksToTake: 0,
                finalThrowValue: null,
                throwsHistory: [],
                drinksGivenFrom31: 0,
                drinksTakenFrom32: 0
            }));

            currentPlayerIndex = 0;
            setupPlayerTurn();
        }

        function setupPlayerTurn() {
            gameState = 'playing';
            const actualPlayerIndex = roundTurnOrder[currentPlayerIndex];
            const currentPlayer = playerRoundData[actualPlayerIndex];
            spelerAanZetH3.textContent = `${currentPlayer.name}`;
            throwsThisTurn = 0;
            currentScoreResult = {};
            currentDice = [0, 0];
            heldDice = [false, false];
            mustThrowHeld = false;
            allowHolding = false;

            updateDiceDisplay();
            scoreDisplayDiv.textContent = "Score: -";
            worpTellerSpan.textContent = throwsThisTurn;
            maxWorpenSpan.textContent = roundThrowsLimit;
            rollBtn.disabled = false;
            rollBtn.textContent = "Gooi";
            showLowestBtn.disabled = false;
            hideMessage();

            die1Div.classList.remove('held', 'clickable', 'shaking', 'cannot-hold');
            die2Div.classList.remove('held', 'clickable', 'shaking', 'cannot-hold');
        }

        // --- Dice Rolling & Animation ---
        function startRollAnimation() {
            rollBtn.disabled = true;
            showLowestBtn.disabled = true;
            allowHolding = false;
            die1Div.classList.remove('clickable', 'held', 'cannot-hold');
            die2Div.classList.remove('clickable', 'held', 'cannot-hold');
            hideMessage();

            if (!heldDice[0]) die1Div.classList.add('shaking');
            if (!heldDice[1]) die2Div.classList.add('shaking');

            let animationDuration = 650;
            let intervalTime = 45;
            let elapsed = 0;

            animationInterval = setInterval(() => {
                if (!heldDice[0]) currentDice[0] = getRandomDieValue();
                if (!heldDice[1]) currentDice[1] = getRandomDieValue();
                updateDiceDisplay(true);
                elapsed += intervalTime;
                if (elapsed >= animationDuration) {
                    finishRoll();
                }
            }, intervalTime);
        }

        function finishRoll() {
            clearInterval(animationInterval);
            animationInterval = null;
            die1Div.classList.remove('shaking');
            die2Div.classList.remove('shaking');
            handleRollResultLogic();
        }

        function getRandomDieValue() {
            return Math.floor(Math.random() * 6) + 1;
        }

        function updateDiceDisplay(isAnimating = false) {
            const dieElements = [die1Div, die2Div];
            dieElements.forEach((el, index) => {
                const valueToShow = (heldDice[index] && !isAnimating) ? el.getAttribute('data-value') : currentDice[index].toString();
                el.setAttribute('data-value', valueToShow);
                el.classList.toggle('held', heldDice[index] && !mustThrowHeld);
                el.classList.remove('cannot-hold');
            });
        }

        // --- Roll Result & Score Logic ---
        function handleRollResultLogic() {
            if (!heldDice[0]) currentDice[0] = getRandomDieValue();
            if (!heldDice[1]) currentDice[1] = getRandomDieValue();
            updateDiceDisplay();

            if (mustThrowHeld) {
                 const originallyHeldIndex = heldDice.findIndex(h => h);
                 if (originallyHeldIndex !== -1) {
                     mustThrowHeld = false;
                     heldDice[originallyHeldIndex] = false;
                     document.getElementById(`die${originallyHeldIndex + 1}`).classList.remove('held');
                 }
             }

            currentScoreResult = calculateScore(currentDice[0], currentDice[1]);
            scoreDisplayDiv.textContent = `Score: ${currentScoreResult.display}`;

            const actualPlayerIndex = roundTurnOrder[currentPlayerIndex];
            const currentPlayer = playerRoundData[actualPlayerIndex];

            // --- Add throw to history (including specials) ---
             currentPlayer.throwsHistory.push({
                 scoreResult: { ...currentScoreResult }
             });

            // Handle special scores (31, 32) - History added above, turn doesn't count
            if (currentScoreResult.type === 'special') {
                 const drinksNow = 1 * Math.pow(2, mexCountThisRound);
                 const slokText = pluralizeSlok(drinksNow);

                 if (currentScoreResult.value === 31) {
                    showTemporaryMessage(`${currentPlayer.name}: 31! Deel ${drinksNow} ${slokText} uit. Gooi opnieuw.`);
                    currentPlayer.drinksGivenFrom31 += drinksNow;
                } else if (currentScoreResult.value === 32) {
                    showTemporaryMessage(`${currentPlayer.name}: 32! Drink ${drinksNow} ${slokText} zelf. Gooi opnieuw.`);
                    currentPlayer.drinksTakenFrom32 += drinksNow;
                }
                heldDice = [false, false];
                allowHolding = false;
                die1Div.classList.remove('held', 'clickable', 'cannot-hold');
                die2Div.classList.remove('held', 'clickable', 'cannot-hold');
                rollBtn.disabled = false;
                showLowestBtn.disabled = false;
                return; // Exit early
            }

            // --- If NOT special, it's a countable throw ---
            throwsThisTurn++;
            worpTellerSpan.textContent = throwsThisTurn;

            // Update player's final tracked score for the round
             currentPlayer.finalThrowValue = currentScoreResult.value;
             currentPlayer.scoreDisplay = currentScoreResult.display;

             // Update Mex Rule Flag if a normal score is rolled
             if (currentScoreResult.type === 'normal') {
                 onlyMexRolledSoFar = false;
             }

            // Handle Mex (21) - Ends turn, history added above
            if (currentScoreResult.type === 'mex') {
                 mexCountThisRound++;
                 const multiplier = Math.pow(2, mexCountThisRound);
                 let mexMsg = `MEX! ${currentPlayer.name} stopt direct.`;
                 // Check if this is the first player *in the current turn order*
                 if (currentPlayerIndex === 0 && throwsThisTurn < roundThrowsLimit) {
                     roundThrowsLimit = throwsThisTurn;
                     maxWorpenSpan.textContent = roundThrowsLimit;
                     mexMsg += ` Nieuwe limiet: ${roundThrowsLimit} worp${roundThrowsLimit === 1 ? '' : 'en'}.`;
                 }
                 mexMsg += ` ${pluralizeSlok(2)} x${multiplier}!`;
                 showTemporaryMessage(mexMsg, 'special');

                 endPlayerTurn();
                 return;
            }

            // Normal roll continues - Check if turn ends
            if (throwsThisTurn >= roundThrowsLimit) {
                 endPlayerTurn();
            } else {
                 // Turn continues - Allow holding based on rules
                 rollBtn.disabled = false;
                 showLowestBtn.disabled = false;
                 allowHolding = true;

                 const dieElements = [die1Div, die2Div];
                 dieElements.forEach( (dieEl, index) => {
                     const dieValue = currentDice[index];
                     if (dieValue >= 1 && dieValue <= 3) {
                         dieEl.classList.add('clickable');
                         dieEl.classList.remove('cannot-hold');
                     } else {
                         dieEl.classList.remove('clickable');
                         dieEl.classList.add('cannot-hold');
                     }
                 });

                 const heldIndex = heldDice.findIndex(h => h);
                 if (heldIndex !== -1) {
                     mustThrowHeld = true;
                     document.getElementById(`die${heldIndex + 1}`).classList.remove('clickable');
                 } else {
                     mustThrowHeld = false;
                 }
            }
        }

        function calculateScore(d1, d2) {
            if (d1 === 0 || d2 === 0) return { value: 0, display: "-", type: 'none'};
            if ((d1 === 2 && d2 === 1) || (d1 === 1 && d2 === 2)) return { value: 1000, display: "Mex", type: 'mex' };
            if ((d1 === 3 && d2 === 1) || (d1 === 1 && d2 === 3)) return { value: 31, display: "31", type: 'special' };
            if ((d1 === 3 && d2 === 2) || (d1 === 2 && d2 === 3)) return { value: 32, display: "32", type: 'special' };
            if (d1 === d2) return { value: d1 * 100, display: `${d1}00`, type: 'normal' };
            const high = Math.max(d1, d2);
            const low = Math.min(d1, d2);
            return { value: high * 10 + low, display: `${high}${low}`, type: 'normal' };
        }

        // --- Die Holding Logic ---
        function handleDieClick(index) {
            if (!allowHolding) return;

            const dieElement = document.getElementById(`die${index + 1}`);
            const dieValue = currentDice[index];
            const otherIndex = 1 - index;
            const otherDieElement = document.getElementById(`die${otherIndex + 1}`);
            const otherDieValue = currentDice[otherIndex];

            // Check locking rule: Cannot hold 4, 5, or 6
            if (dieValue > 3) {
                 showTemporaryMessage(`Je kunt ${dieValue} niet vasthouden (alleen 1, 2 of 3).`);
                 dieElement.classList.add('cannot-hold');
                 setTimeout(() => dieElement.classList.remove('cannot-hold'), 500);
                 return;
            }

            // Prevent clicking the die that MUST be thrown
             if (mustThrowHeld && heldDice[otherIndex]) {
                showTemporaryMessage("Je moet de niet-vastgehouden dobbelsteen gooien.");
                return;
            }

            // Prevent holding both dice
            if (!heldDice[index] && heldDice[otherIndex]) {
                 showTemporaryMessage("Je kunt maar één dobbelsteen vasthouden.");
                 return;
            }

            // Toggle the held state
            heldDice[index] = !heldDice[index];
            dieElement.classList.toggle('held', heldDice[index]);

            // Update clickability and mustThrowHeld status
            if (heldDice[index]) { // Just held this die
                mustThrowHeld = true;
                dieElement.classList.remove('clickable');
                if (otherDieValue <= 3) {
                     otherDieElement.classList.add('clickable');
                     otherDieElement.classList.remove('cannot-hold');
                 } else {
                     otherDieElement.classList.remove('clickable');
                     otherDieElement.classList.add('cannot-hold');
                 }
            } else { // Just released this die
                mustThrowHeld = false;
                 if (dieValue <= 3) dieElement.classList.add('clickable');
                 if (otherDieValue <= 3) otherDieElement.classList.add('clickable');
            }
        }

        // --- Turn & Round Ending Logic ---
        function endPlayerTurn() {
            gameState = 'turnOver';
            rollBtn.textContent = 'Volgende Speler';
            rollBtn.disabled = false;
            showLowestBtn.disabled = true;
            allowHolding = false;
            die1Div.classList.remove('clickable', 'shaking', 'held', 'cannot-hold');
            die2Div.classList.remove('clickable', 'shaking', 'held', 'cannot-hold');
            heldDice = [false, false];
            mustThrowHeld = false;

            const actualPlayerIndex = roundTurnOrder[currentPlayerIndex];
            const finalScoreValue = playerRoundData[actualPlayerIndex].finalThrowValue;
            const currentPlayerName = playerRoundData[actualPlayerIndex].name;
            const currentScoreDisplay = playerRoundData[actualPlayerIndex].scoreDisplay;

            // --- Lowest Score & Overtake Logic ---
            // Only process if it's a valid final score (not null or special)
            if (finalScoreValue !== null && finalScoreValue !== 31 && finalScoreValue !== 32) {
                 const scoreToCompare = finalScoreValue;
                 const canMexBeLowest = onlyMexRolledSoFar && scoreToCompare === 1000;

                // Is this score lower than the current lowest?
                 if (scoreToCompare < roundLowestScore || (canMexBeLowest && roundLowestScore === Infinity)) {
                     roundLowestScore = scoreToCompare;
                     roundLowestPlayerIndices = [actualPlayerIndex]; // This player is now lowest
                     console.log(`New lowest score: ${currentScoreDisplay} by ${currentPlayerName}`);
                 }
                 // Does this score tie the current lowest?
                 else if (scoreToCompare === roundLowestScore) {
                     // Only trigger overtake/tie logic if this player wasn't already lowest
                     if (!roundLowestPlayerIndices.includes(actualPlayerIndex)) {
                         const previousLowestPlayerIndex = roundLowestPlayerIndices[0]; // Index of who WAS lowest

                         // --- Overtake Action ---
                         // Calculate drinks NOW based on current multiplier
                         const drinksForThisOvertake = 1 * Math.pow(2, mexCountThisRound);
                         // Add/update entry in the map for the player who WAS lowest
                         const currentOvertakeDrinks = overtakenPlayersMap.get(previousLowestPlayerIndex) || 0;
                         overtakenPlayersMap.set(previousLowestPlayerIndex, currentOvertakeDrinks + drinksForThisOvertake);
                         console.log(`Player ${previousLowestPlayerIndex} overtaken, owes ${overtakenPlayersMap.get(previousLowestPlayerIndex)} drinks`);

                         // Current player takes over the lowest spot
                         roundLowestPlayerIndices = [actualPlayerIndex];

                         showTemporaryMessage(`${currentPlayerName} (${currentScoreDisplay}) evenaart laagste! ${playerRoundData[previousLowestPlayerIndex]?.name || 'Iemand'} moet extra drinken!`, 'special');
                         console.log(`${currentPlayerName} overtakes/ties lowest score ${currentScoreDisplay} from ${playerRoundData[previousLowestPlayerIndex]?.name || 'Previous'}`);
                     }
                     // If player already holds/shares lowest, do nothing new regarding overtake.
                 }
            }

            // --- End Turn Message ---
            if (!messageAreaDiv.classList.contains('visible')) {
                 const displayScore = currentScoreDisplay || "Geen score";
                showTemporaryMessage(`Beurt van ${currentPlayerName} (${displayScore}) is klaar. Klik 'Volgende Speler'.`);
            }
        }


        function advanceToNext() {
            currentPlayerIndex++;
            if (currentPlayerIndex < roundTurnOrder.length) {
                setupPlayerTurn();
            } else {
                endRound();
            }
        }

        function endRound() {
            gameState = 'roundOver';
            rollBtn.disabled = true;
            rollBtn.textContent = "Ronde Klaar";
            showLowestBtn.disabled = true;
            hideMessage();

            let drinksMultiplier = Math.pow(2, mexCountThisRound);
            let actionMessages = [];
            let scoreHTML = "<strong>Scores</strong><br>";
            let actualRoundLowestNormalScoreValue = Infinity; // Track lowest NORMAL score value
            let lowestScoreDisplayValue = null; // Display string of lowest NORMAL score

            // --- Pass 1: Build Score Display HTML (in Turn Order) & Find Lowest Actual Normal Score ---
            for (let i = 0; i < roundTurnOrder.length; i++) {
                 const actualPlayerIndex = roundTurnOrder[i];
                 const data = playerRoundData[actualPlayerIndex];

                 scoreHTML += `<div class="score-section">`;
                 scoreHTML += `<strong class="player-name">${data.name}:</strong>`;
                 scoreHTML += `<span class="throw-history" data-player-index="${data.id}">`; // Use original ID for data attr

                 let finalThrowIndex = -1;
                 if (data.throwsHistory.length > 0) {
                     for(let j = data.throwsHistory.length - 1; j >= 0; j--) {
                         const throwRes = data.throwsHistory[j].scoreResult;
                         if(throwRes.type !== 'special') {
                             finalThrowIndex = j;
                             if(throwRes.type === 'normal' && throwRes.value < actualRoundLowestNormalScoreValue) {
                                 actualRoundLowestNormalScoreValue = throwRes.value;
                                 lowestScoreDisplayValue = throwRes.display;
                             }
                             break;
                         }
                     }

                     data.throwsHistory.forEach((throwData, index) => {
                         const scoreStr = throwData.scoreResult.display;
                         let classes = [];
                         if (index === finalThrowIndex) classes.push('final-throw');
                         if (throwData.scoreResult.type === 'special') classes.push('special-throw');
                         scoreHTML += `<span class="${classes.join(' ')}" data-score-value="${throwData.scoreResult.value}" data-score-type="${throwData.scoreResult.type}">${scoreStr}</span>`;
                     });
                 } else {
                     scoreHTML += ` (Geen geldige worpen)`;
                 }
                 scoreHTML += `</span></div>`;
             }
            resultatenScoresDiv.innerHTML = scoreHTML;

             // --- Pass 2: Highlight Final Lowest NORMAL Scores ---
             if (lowestScoreDisplayValue !== null && roundLowestScore !== 1000) {
                  roundLowestPlayerIndices.forEach(playerIndex => { // Use the FINAL list
                      const playerHistorySpan = resultatenScoresDiv.querySelector(`.throw-history[data-player-index="${playerIndex}"]`);
                      if (playerHistorySpan) {
                          const finalThrowSpan = playerHistorySpan.querySelector('.final-throw');
                          if (finalThrowSpan && finalThrowSpan.textContent === lowestScoreDisplayValue && finalThrowSpan.dataset.scoreType === 'normal') {
                              finalThrowSpan.classList.add('lowest-score-highlight');
                          }
                      }
                  });
             }

            // --- Calculate Drinks and Actions ---
            // 1. Process 31/32 drinks
            playerRoundData.forEach((data) => {
                 if (data.drinksGivenFrom31 > 0) actionMessages.push(`<strong>${data.name}</strong> deelt ${data.drinksGivenFrom31} ${pluralizeSlok(data.drinksGivenFrom31)} uit (door 31).`);
                 if (data.drinksTakenFrom32 > 0) actionMessages.push(`<strong>${data.name}</strong> drinkt ${data.drinksTakenFrom32} ${pluralizeSlok(data.drinksTakenFrom32)} zelf (door 32).`);
             });

            // 2. Process Accumulated Overtake Drinks
            if (overtakenPlayersMap.size > 0) {
                overtakenPlayersMap.forEach((totalOvertakeDrinks, playerIndex) => {
                    if (playerRoundData[playerIndex]) { // Ensure player data exists
                        const overtakenPlayerName = playerRoundData[playerIndex].name;
                        const overtakenScore = playerRoundData[playerIndex].scoreDisplay; // Score they were holding when overtaken
                        actionMessages.push(`<strong>${overtakenPlayerName}</strong> drinkt ${totalOvertakeDrinks} ${pluralizeSlok(totalOvertakeDrinks)} (score ${overtakenScore || ''} overgenomen).`);
                        playerRoundData[playerIndex].drinksToTake += totalOvertakeDrinks;
                    }
                });
            }

            // 3. Process Lowest Score Penalty (only for those NOT penalized by overtake)
            if (roundLowestPlayerIndices.length > 0 && roundLowestScore !== Infinity) {
                 const drinksForLowest = 1 * drinksMultiplier;
                 const lowestPlayersNotOvertaken = []; // Store names of those getting lowest penalty
                 const lowestPlayerIndicesNotOvertaken = []; // Store indices

                 roundLowestPlayerIndices.forEach(index => {
                     // Assign drinks ONLY if this player was NOT penalized via the overtake map
                     if (!overtakenPlayersMap.has(index)) {
                         if (playerRoundData[index]) {
                             playerRoundData[index].drinksToTake += drinksForLowest;
                             lowestPlayersNotOvertaken.push(`<strong>${playerRoundData[index].name}</strong>`);
                             lowestPlayerIndicesNotOvertaken.push(index);
                         }
                     }
                 });

                 // Generate message only if there are players penalized for being lowest (and not overtaken)
                 if (lowestPlayersNotOvertaken.length > 0) {
                     let displayScoreForMsg = "";
                     if (roundLowestScore === 1000) displayScoreForMsg = "Mex";
                     else if (lowestScoreDisplayValue) displayScoreForMsg = lowestScoreDisplayValue;
                     else displayScoreForMsg = roundLowestScore; // Fallback

                     if (lowestPlayersNotOvertaken.length === 1) {
                         actionMessages.push(`${lowestPlayersNotOvertaken[0]} heeft de laagste score (${displayScoreForMsg}) en drinkt ${drinksForLowest} ${pluralizeSlok(drinksForLowest)}.`);
                     } else {
                         actionMessages.push(`Gelijkspel laagste score (${displayScoreForMsg}): ${lowestPlayersNotOvertaken.join(', ')} drinken elk ${drinksForLowest} ${pluralizeSlok(drinksForLowest)}.`);
                     }
                 }
            }
            // Handle case where no valid scores were thrown
            else if (roundLowestScore === Infinity && overtakenPlayersMap.size === 0) {
                 actionMessages.push("Geen geldige laagste score bepaald deze ronde.");
            }

            // --- Build Action Display ---
             let actionsHTML = "<strong class='actions-section'>Acties & Drankjes</strong><br>";
             actionsHTML += '<div class="actions-section">';
             actionsHTML += actionMessages.length > 0 ? actionMessages.join('<br>') : "Geen speciale acties deze ronde.";
             if (mexCountThisRound > 0) {
                  const mexWord = numberToWord(mexCountThisRound);
                 actionsHTML += `<br><em>(${pluralizeSlok(2)} x${drinksMultiplier} door ${mexWord} Mex worp${mexCountThisRound > 1 ? 'en' : ''})</em>`;
             }
             actionsHTML += '</div>';
            resultatenActiesDiv.innerHTML = actionsHTML;

            // --- Prepare for Next Round ---
            // Save the indices of players who finished with the lowest score
            lastRoundLowestIndices = roundLowestPlayerIndices.length > 0 ? [...roundLowestPlayerIndices] : [];

            // Show results and enable next round
            rondeResultatenDiv.style.display = 'block';
            nextRoundBtn.disabled = false;
        }


        // --- Utility Functions ---
        function showLowestScoreInfo() {
            if (roundLowestScore === Infinity) {
                showTemporaryMessage("Nog geen laagste score bepaald in deze ronde.");
            } else {
                 let lowestScoreDisplay;
                 if (roundLowestScore === 1000) {
                     lowestScoreDisplay = "Mex";
                 } else if (roundLowestPlayerIndices.length > 0 && playerRoundData[roundLowestPlayerIndices[0]]) {
                     // Try to find the *actual* display value from the history of the first lowest player
                     const firstLowestPlayer = playerRoundData[roundLowestPlayerIndices[0]];
                     const lastValidThrow = firstLowestPlayer.throwsHistory.slice().reverse().find(t => t.scoreResult.type !== 'special');
                      if(lastValidThrow && lastValidThrow.scoreResult.value === roundLowestScore){
                          lowestScoreDisplay = lastValidThrow.scoreResult.display;
                      } else {
                           lowestScoreDisplay = roundLowestScore.toString(); // Fallback
                      }
                 } else {
                      lowestScoreDisplay = roundLowestScore.toString(); // Fallback
                 }

                 const lowestPlayerNames = roundLowestPlayerIndices.map(i => playerRoundData[i]?.name || 'Onbekend').join(', ');
                showTemporaryMessage(`Huidige laagste score: ${lowestScoreDisplay} (van ${lowestPlayerNames})`);
            }
        }

        function showTemporaryMessage(msg, type = 'info') {
            messageAreaDiv.innerHTML = msg;
            messageAreaDiv.className = 'message-area visible';
            if (type === 'special') {
                messageAreaDiv.classList.add('special');
            }
            // Optional: Auto-hide after a delay
            // setTimeout(hideMessage, 5000);
        }

        function hideMessage() {
            messageAreaDiv.className = 'message-area';
        }

        // --- Initialisation ---
        checkStartGameButton();
        hideMessage();

    </script>

</body>
</html>